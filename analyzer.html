<head><base target="_blank">
    <link rel="shortcut icon" href="#">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* changing font for all text */
        body{
            font-family: Arial, Helvetica, sans-serif;
        }
        /* establishing types for different kinds of text used*/
        .title{
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .prompt{
            color: blue;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .result-text{
            color: green;
            display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
        }
        .result-number{
            font-weight: bold;
            margin: 0px;
            display: inline-block;
        }
        /* display box for calculators */
        .calculator{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            /*display: inline-block; /* let them show side by side */
        }
        /* display box for calculators */
        .analyzer{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            float:left;
            /*display: inline-block; /* let them show side by side */
        }
        .result-box{
            border: 1px solid black;
            background-color: white;
            padding: 5px;
        }
        .bar-graph{
            border: 1px solid black;
            padding: 5px;
            margin: 5px;
            min-height: 100px;
            min-width: 464px;
        }
        .graph-bar{
            display: inline-block;
            margin: 2px;
        }
        .miss-bar{
            border: 1px solid black;
            /*border-bottom: 0px;*/
            background-color: red;
            width: 40px;
        }
        .hit-bar{
            
            border: 1px solid black;
            background-color: #1166dd;
            width: 40px;
        }
        table {
            border: 2px solid rgb(80 80 80);
            border-collapse: collapse;
            border-spacing: 0;
        }
        th {
            border: 1px solid rgb(120 120 120);
            padding-top: 3px;
            padding-bottom: 3px;
            padding-left: 5px;
            padding-right: 5px;
        }
        td {
            border: 1px solid rgb(160 160 160);
            padding-top: 2px;
            padding-bottom: 2px;
            padding-left: 5px;
            padding-right: 5px;
        }
        .table-num{
            color: green;
            /*display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
            text-align: center;
        }
        .error-text{
            color: red;
        }
        .info-box{
            width: 800px;
            border: 1px solid black;
            background-color: #EEEEEE;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            /*float:left;*/
        }
        .angry-title{
            color: red;
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .warning-box{
            width: 800px;
            border: 1px solid black;
            background-color: mistyrose;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            float:left;
        }
    </style>
</head>
<body onload="disableButton()">
    <script>
        //import  testDict from './test.json' assert {type: 'json'};
        // const testDict = JSON.parse(open('./test.json'));
        //var fs = require('fs');
        //const testDict = JSON.parse(fs.readFileSync('./test.json', 'utf8'));\
        var testDict;
        const frankTable = [
            [
                [0.661, 0.699, 0.735, 0.767, 0.796, 0.821, 0.844, 0.867, 0.885, 0.900, 0.916, 0.928, 0.940, 0.950, 0.958, 0.965, 0.972, 0.977, 0.982, 0.986, 0.989, 0.992, 0.994, 0.996, 0.997, 0.998, 0.999, 0.999, 1, 1, 1, 1]
            ],
            [
                [0.698, 0.736, 0.769, 0.800, 0.827, 0.851, 0.872, 0.891, 0.907, 0.921, 0.934, 0.945, 0.954, 0.962, 0.969, 0.975, 0.980, 0.984, 0.988, 0.990, 0.993, 0.995, 0.996, 0.997, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1],
                [0.274, 0.317, 0.362, 0.407, 0.450, 0.492, 0.535, 0.574, 0.612, 0.649, 0.684, 0.716, 0.748, 0.778, 0.803, 0.827, 0.851, 0.871, 0.890, 0.907, 0.923, 0.936, 0.949, 0.959, 0.968, 0.976, 0.982, 0.988, 0.992, 0.995, 0.998, 1]
            ],
            [
                [0.738, 0.776, 0.807, 0.835, 0.860, 0.882, 0.901, 0.917, 0.931, 0.943, 0.953, 0.962, 0.969, 0.976, 0.981, 0.985, 0.988, 0.991, 0.994, 0.995, 0.997, 0.998, 0.999, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1],
                [0.322, 0.371, 0.420, 0.468, 0.512, 0.558, 0.601, 0.641, 0.679, 0.714, 0.748, 0.780, 0.807, 0.834, 0.858, 0.879, 0.898, 0.915, 0.930, 0.943, 0.955, 0.965, 0.973, 0.980, 0.986, 0.990, 0.994, 0.997, 0.998, 1, 1, 1],
                [0.080, 0.102, 0.129, 0.159, 0.190, 0.224, 0.260, 0.297, 0.335, 0.374, 0.414, 0.456, 0.495, 0.534, 0.574, 0.613, 0.648, 0.684, 0.720, 0.752, 0.783, 0.813, 0.840, 0.865, 0.889, 0.910, 0.930, 0.948, 0.963, 0.977, 0.990, 1]
            ],
            [
                [0.785, 0.819, 0.950, 0.875, 0.897, 0.915, 0.931, 0.944, 0.955, 0.964, 0.972, 0.978, 0.983, 0.987, 0.990, 0.993, 0.995, 0.996, 0.998, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0.385, 0.439, 0.491, 0.543, 0.591, 0.637, 0.679, 0.719, 0.756, 0.790, 0.820, 0.848, 0.871, 0.894, 0.912, 0.929, 0.943, 0.956, 0.966, 0.974, 0.981, 0.986, 0.991, 0.994, 0.996, 0.998, 0.999, 1, 1, 1, 1, 1],
                [0.110, 0.141, 0.175, 0.212, 0.252, 0.292, 0.337, 0.381, 0.425, 0.471, 0.517, 0.560, 0.604, 0.645, 0.685, 0.723, 0.758, 0.791, 0.824, 0.851, 0.878, 0.901, 0.923, 0.940, 0.956, 0.969, 0.980, 0.988, 0.994, 0.998, 1, 1],
                [0.018, 0.026, 0.037, 0.050, 0.066, 0.085, 0.106, 0.130, 0.156, 0.186, 0.218, 0.251, 0.287, 0.325, 0.365, 0.405, 0.447, 0.489, 0.532, 0.574, 0.617, 0.658, 0.700, 0.740, 0.779, 0.816, 0.852, 0.885, 0.918, 0.947, 0.975, 1]
            ],
            [
                [0.831, 0.862, 0.888, 0.910, 0.928, 0.943, 0.956, 0.965, 0.974, 0.980, 0.985, 0.989, 0.992, 0.994, 0.996, 0.997, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0.458, 0.516, 0.573, 0.624, 0.674, 0.720, 0.760, 0.797, 0.829, 0.858, 0.884, 0.906, 0.924, 0.940, 0.954, 0.965, 0.973, 0.981, 0.986, 0.991, 0.994, 0.996, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1],
                [0.152, 0.192, 0.236, 0.283, 0.333, 0.383, 0.434, 0.483, 0.535, 0.584, 0.631, 0.675, 0.719, 0.758, 0.794, 0.827, 0.858, 0.884, 0.909, 0.928, 0.946, 0.960, 0.972, 0.981, 0.988, 0.993, 0.997, 0.999, 1, 1, 1, 1],
                [0.029, 0.042, 0.059, 0.079, 0.103, 0.131, 0.163, 0.197, 0.233, 0.273, 0.316, 0.361, 0.407, 0.454, 0.500, 0.548, 0.597, 0.643, 0.687, 0.731, 0.773, 0.812, 0.847, 0.880, 0.909, 0.935, 0.956, 0.974, 0.987, 0.996, 1, 1]
            ],
            [
                [0.871, 0.898, 0.920, 0.938, 0.953, 0.964, 0.973, 0.980, 0.985, 0.989, 0.992, 0.995, 0.996, 0.998, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0.536, 0.597, 0.653, 0.705, 0.752, 0.793, 0.831, 0.862, 0.889, 0.912, 0.931, 0.947, 0.960, 0.971, 0.978, 0.985, 0.989, 0.993, 0.995, 0.997, 0.998, 0.999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0.206, 0.257, 0.311, 0.369, 0.425, 0.482, 0.540, 0.594, 0.645, 0.694, 0.738, 0.781, 0.818, 0.852, 0.881, 0.906, 0.928, 0.946, 0.960, 0.972, 0.981, 0.988, 0.992, 0.996, 0.998, 0.999, 1, 1, 1, 1, 1, 1]
            ],
            [
                [],
                [0.611, 0.674, 0.729, 0.777, 0.819, 0.856, 0.885, 0.911, 0.933, 0.949, 0.962, 0.973, 0.980, 0.986, 0.991, 0.994, 0.996, 0.998, 0.999, 0.999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0.271, 0.333, 0.397, 0.462, 0.524, 0.586, 0.643, 0.695, 0.746, 0.790, 0.829, 0.863, 0.893, 0.918, 0.938, 0.954, 0.967, 0.978, 0.985, 0.990, 0.994, 0.997, 0.998, 0.999, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        ]

        var landTypes;
        var landCount;
        var iterations;
        var decklist;

        var manaDict;
        var oneDropDict;
        var twoDropDict;
        var mullLands;

        var white;
        var blue;
        var black;
        var red;
        var green;

        var approxColors;
        var approxSamples;
        var deckColors;

        function fact(x){
            let y = x
            while(x>2){
                x=x-1
                y=y*x
            }
            if(y==0){y=y+1}
            return y
        }
    
        function choose(x,y){
            let z = (fact(x))/(fact(y)*fact(x-y))
            return z
        }
        
        function sum(arr){
            return arr.reduce((a, b) => a + b, 0);
        }
        // These drawType functions are the foundation of most of the tools. They seem to be working well for me, but it might be good to be extra sure they're working right

        // given deck size, type count, draw size, and quota, calculates the chance of drawing exactly the quota of that type
        function drawType(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = choose(allTotal-typeTotal, allDrawn-typeDrawn)*choose(typeTotal, typeDrawn)/choose(allTotal, allDrawn);
            return x;
        }

        // given deck size, type count, draw size, and type quota, run drawType for every amount >= quota and sum results
        // had to be altered to not attempt to draw more than exist in deck
        function drawTypeMin(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = 0;
            for(let i = typeDrawn; i <= allDrawn && i <= typeTotal; i++){
                x += drawType(allTotal, typeTotal, allDrawn, i);
            }
            return x;
        }

        // given deck size, 2 type counts, draw size, and 2 type quotas, find chance of meeting both quotas
        // walks through all satisfactory amounts of first type, and uses drawTypeMin to see if second type will meet quota
        // multiplies the two together to get the intersecting probability, and returns the sum
        // Since we already accounted for the number of type A being drawn, the second calculation is run with all type A removed from the deck
        function drawTwoTypeMin(allTotal, totalA, totalB, allDrawn, drawnA, drawnB){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTypeMin(allTotal-totalA, totalB, allDrawn-i, drawnB);
            }
            return x;
        }

        // like drawTwoTypeMin, but for three. The principle is the same
        function drawThreeTypeMin(allTotal, totalA, totalB, totalC, allDrawn, drawnA, drawnB, drawnC){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTwoTypeMin(allTotal - totalA, totalB, totalC, allDrawn-i, drawnB, drawnC);
            }
            return x;
        }
        
        //odds of drawing a card of a type by a certain turn, modified to use drawTypeMin
        function drawby(T,N){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                N = parseFloat(document.getElementById('N').value) || 0,
                T = parseFloat(document.getElementById('T').value) || 0,
                result = document.getElementById('result-text');
            //let x=(1-(choose(99-N,7+T)/choose(99,7+T)));
            let x = (drawTypeMin(99, N, T+7, 1));
            result[textType] = x.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:1});
        } 

        function listProcess(){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                L = document.getElementById('decklist').value,
                result = document.getElementById('analyzer-result');
            
            entries = L.split('\n');
            console.log(entries);
            result[textType] = entries[0];
        }


        function canAffordColor(cmc, pips, sources){
            if(cmc <= 7 && pips > 0 && pips < 5){
                if(sources < 10){
                    return frankTable[cmc - 1][pips - 1][0] * (sources / 10.0) ** pips;
                }
                console.log("Frank: " + frankTable[cmc - 1][pips - 1][sources - 10]);
                console.log("Mine: " + drawTypeMin(41, sources, cmc, pips));
                return frankTable[cmc - 1][pips - 1][sources - 10];
            }
            return drawTypeMin(41, sources, cmc, pips);
        }

        function processCost(cost){
            return Math.sign(cost.w) + 2 * Math.sign(cost.u) + 4 * Math.sign(cost.b) + 8 * Math.sign(cost.r) + 16 * Math.sign(cost.g);
        }

        function numColors(cost){
            return Math.sign(cost.w) + Math.sign(cost.u) + Math.sign(cost.b) + Math.sign(cost.r) + Math.sign(cost.g)
        }

        function colorReqs(cost){
            return {
                w: cost.w,
                u: cost.u,
                b: cost.b,
                r: cost.r,
                g: cost.g
            };
        }

        //encode the color pips in a given cost using prime factors
        function pipsToNum(cost){
            return 2 ** cost.w * 3 ** cost.u * 5 ** cost.b * 7 ** cost.r * 11 ** cost.g;
        }

        function numToPips(num){
            if(num == 0){
                console.log("Something has gone very wrong");
                return 0;
            }
            let out = {
                w: 0,
                u: 0,
                b: 0,
                r: 0,
                g: 0
            };
            while(num % 2 == 0){
                out.w = out.w + 1;
                num /= 2;
            }
            while(num % 3 == 0){
                out.u = out.u + 1;
                num /= 3;
            }
            while(num % 5 == 0){
                out.b = out.b + 1;
                num /= 5;
            }
            while(num % 7 == 0){
                out.r = out.r + 1;
                num /= 7;
            }
            while(num % 11 == 0){
                out.g = out.g + 1;
                num /= 11;
            }
            return out;
        }

        function landFilter(cost){
            let costCode = processCost(cost);
            let limitedLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                limitedLandTypes[i&costCode] += landTypes[i]
            }
            return limitedLandTypes;
        }

        function sourcesFromLands(myLandTypes){
            let sources = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < 32; j++){
                    sources[i] += myLandTypes[j] * Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
            }
            return sources;
        }
        // Take a land count and set of land categories that are not whole numbers, and convert them to a set of whole numbers
        // These whole numbers need to behave as closely as possible to how those fractional lands would have.
        // I am mainly trying to preserve the output on the color combination requirement array.
        // I am currently using a search function that might be a little bit expensive, but not excessively so compared to the resources used by the analysis itself
        function roundLands(myLandTypes){
            //
            
            /*let roundLandTypes = new Array(32).fill(0);
            let myLandCount = 0;
            let roundLandCount = 0;
            let roundingErrors = new Array(32).fill(0);
            // round values to the nearest, check on errors.
            for(let i = 0; i < 32; i++){
                roundLandTypes[i] = Math.round(myLandTypes[i]);
                roundLandCount += roundLandTypes[i];
                myLandCount += myLandTypes[i];
                let roundError = roundLandTypes[i] - myLandTypes[i];
                for(let j = 0; j < 32; j++){
                    roundingErrors[j] += roundError * Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
            }

            let backupLandCount = roundLandCount;
            let backupLandTypes = roundLandTypes.slice();
            let backupErrors = roundingErrors.slice();

            let sign = 1
            let sumSq = 0;
            for(let i= 0; i < 32; i++){
                sumSq += roundingErrors[i] ** 2;
            }
            console.log("Default Error: " + sumSq);
            let oldSumSq = sumSq;*/
            

            /*for(let k = 0; k < 100; k++){
                let maxIndex = -1;
                let maxValue = k * (1 + (roundLandCount - myLandCount) * sign);
                for(let i = 0; i < 32; i++){
                    let value = 0;
                    for(let j = 0; j < 32; j++){
                        value -= sign * (roundingErrors[j] - sign / 2) * Math.sign(j & i);
                    }
                    if(sign == -1 && roundLandCount[i] <= 0){
                        value -= 1000;
                    }
                    if(value > maxValue){
                        maxValue = value;
                        maxIndex = i;
                    }
                }
                if(maxIndex != -1){
                    roundLandTypes[maxIndex] += sign;
                    roundLandCount += sign;
                    for(let j = 0; j < 32; j++){
                        roundingErrors[j] += sign * Math.sign(j & maxIndex);
                    }
                    sumSq = 0;
                    for(let i= 0; i < 32; i++){
                        sumSq += roundingErrors[i] ** 2;
                    }
                    //console.log(sign + " " + maxIndex + " " + maxValue + " " + sumSq);
                }
                
                sign *= -1;
                //console.log(k); 
            }

            //console.log("Total: " + backupLandCount + ", " + roundLandCount + ", " + myLandCount);
            for(let i= 0; i < 32; i++){
                //console.log(i + ": " + backupLandTypes[i] + ", " + roundLandTypes[i] + ", " + myLandTypes[i]);
            }

            //console.log("Errors");
            sumSq = 0;
            for(let i= 0; i < 32; i++){
                //console.log(i + ": "+ backupErrors[i] + ", " + roundingErrors[i]);
                sumSq += roundingErrors[i] ** 2;
            }
            console.log("Algo 1 Error: " + sumSq);*/
            let result = roundLandSearch(myLandTypes.slice())
            let searchLandTypes = result[0];
            let reportedError = result[1];
            let evaluatedError = new Array(32).fill(0);

            //let benchmark = sourcesFromLands(myLandTypes);
            //let resultSources = sourcesFromLands(searchLandTypes);
            /*sumSq = 0;
            for(let i= 0; i < 32; i++){
                //console.log(i + ": "+ backupErrors[i] + ", " + roundingErrors[i]);
                evaluatedError[i] = benchmark[i] - resultSources[i];
                sumSq += evaluatedError[i] ** 2;
            }
            if(sumSq != reportedError){
                console.log("Error! Function reported error of " + reportedError + ", but external validation shows it was actually " + sumSq);
            }*/
            //console.log("Algo 2 Error: " + reportedError);
            return searchLandTypes;
        }

        function roundLandSearch(myLandTypes){
            let myLandCount = sum(myLandTypes);
            let roundLandCount = Math.round(myLandCount);
            let floorLandTypes = new Array(32).fill(0);
            let floorLandCount = 0;
            for(let i = 0; i < 32; i++){
                floorLandTypes[i] = Math.floor(myLandTypes[i]);
                floorLandCount += floorLandTypes[i];
            }
            let benchmark = sourcesFromLands(myLandTypes);
            let floorSources = sourcesFromLands(floorLandTypes);
            let error = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                error[i] = floorSources[i] - benchmark[i];
            }
            return roundSearch(floorLandTypes.slice(), myLandTypes, roundLandCount - floorLandCount, 0, error);
        }

        function roundSearch(myRoundLands, myLandTypes, landsToAdd, i, error){
            while(myLandTypes[i] <= myRoundLands[i] && i < 31){
                i++;
            }
            if(landsToAdd < 1 || i > 31){
                let sumSq = 0;
                for(let j = 0; j < 32; j++){
                    sumSq += error[j] ** 2;
                }
                if(Number.isNaN(sumSq)){
                    console.log("Uh-Oh");
                }
                return [myRoundLands, sumSq + landsToAdd * 100, error];
            }
            let set1 = roundSearch(myRoundLands.slice(), myLandTypes, landsToAdd, i + 1, error);
            let newRoundLands = myRoundLands.slice();
            newRoundLands[i] += 1;
            let newError = error.slice();
            for(let j = 0; j < 32; j++){
                newError[j] += Math.sign(j & i);
            }
            let set2 = roundSearch(newRoundLands, myLandTypes, landsToAdd - 1, i + 1, newError);
            //let sources1 = sourcesFromLands(set1);
            //let sources2 = sourcesFromLands(set2);
            
            //let error1 = 0;
            //let error2 = 0;
            //for(let j = 0; j < 32; j++){
                //error1 += (benchmark - sources1) ** 2;
                //error2 += (benchmark - sources1) ** 2;
            //}
            if(set1[1] > set2[1]){
                return set2;
                //console.log("see? This happens");
            }
            return set1;
        }

        function testLandRounding(){
            let myLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                myLandTypes[i] = landTypes[i] + Math.random();
            }
            roundLands(myLandTypes);
        }

        function pipDist(cost){

            if(approxColors == undefined){
                approxColors = 5;
            }
            if(approxSamples == undefined){
                approxSamples = 10000;
            }
            let roundedLands = roundLands(landFilter(cost));
            let roundedLandCount = roundedLands.reduce((a, b) => a + b, 0); //sum

            let canCast = new Array(11);
            let comboReqs = getComboReqs(cost);
            if(numColors(cost) < approxColors){
                for(let n = 0; n <= 10; n++){
                    result = rLandTest(cost, roundedLands, n, roundedLandCount, 31, [], 1, structuredClone(comboReqs));
                    canCast[n] = result;
                }
            }else{
                for(let n = 0; n <= 10; n++){
                    result = landTestUniformSample(cost, roundedLands, n, roundedLandCount, 31, [], 0, approxSamples, structuredClone(comboReqs));
                    canCast[n] = (result / approxSamples);
                }
            }

            
            return canCast;
        }

        function calcMullLands(){
            let openingDist = new Array(8);
            let mullDist = new Array(8);
            mullLands = new Array(8).fill(0);
            let mullAmount = 0;
            // distribution for a random hand
            for(let i = 0; i <= 7; i++){
                openingDist[i] = drawType(99, landCount, 7, i);
                mullDist[i] = openingDist[i];
            }
            //console.log(mullDist);

            //free mull, shoot for at least three
            mullAmount = mullDist[0] + mullDist[1] + mullDist[2] + mullDist[6] + mullDist[7];
            for(let i = 3; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            for(let i = 0; i <= 7; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            //console.log(mullLands);
            
            // Second mull, accept 2 if needed
            mullAmount = mullDist[0] + mullDist[1] + mullDist[6] + mullDist[7];
            for(let i = 2; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // shoot for 3 lands with our discards
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 7; i++){
                mullDist[i - 1] += openingDist[i] * mullAmount;
            }
            //console.log(mullLands);

            // After we discard to 6, the 6 and 7 land hands are now 5 and 6 land hands
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5] + mullDist[6];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard 2, once again shooting for 3 lands
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            mullDist[3] += openingDist[4] * mullAmount;
            for(let i = 5; i <= 7; i++){
                mullDist[i - 2] += openingDist[i] * mullAmount;
            }
            //console.log(mullLands);

            // After we discard to 5, we'll settle for at least one spell
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard to 4, 3 lands again
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 6; i++){
                mullDist[3] += openingDist[i] * mullAmount;
            }
            mullDist[4] += openingDist[7] * mullAmount;

            for(let i = 0; i < 7; i++){
                mullLands[i] += mullDist[i];
            }
            //console.log(mullLands);
            //only keep after 4
        }

        function landsAtTurn(turn){
            let landDist = new Array(11).fill(0);
            for(let startLands = 0; startLands < 7; startLands++){
                for(let drawnLands = 0; drawnLands <= turn; drawnLands++){
                    landDist[Math.min(startLands + drawnLands, 10)] += mullLands[startLands] * drawType(92 - turn, landCount - startLands, turn, drawnLands);
                }
            }
            return landDist;
        }

        // Recursively testing different combinations of lands
        // Moving through the list of possible land types, if one is present in the deck, calculate the different possibilities for how many are in there.
        // Then adjust the numbers to feed back into rLandTest to account for the rest
        function rLandTest(cost, myLandTypes, numLands, myLandCount, i, pickedLands, scale, comboReqs){
            // check if mana requirements are already satisfied
            if(Math.max(...comboReqs) <= 0){
                return 1;
            } 
            // check if mana requirements are unreachable
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            let success = 0.0;
            let total = 0.0;
            iterations++;
            // scan forward through the land categories to find one thats in the deck
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            // check point of no return for each color
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            // run through the different numbers of the category of land that can be drawn, test their probability and recursively check with the remaining lands of each of them.
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    result = rLandTest(cost, myLandTypes.slice(), numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), p * scale, structuredClone(comboReqs));
                    success += p * result;
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
                /*for(let k = 1; k < 32; k *= 2){
                    let satisfied = true;
                    let colorSum = 0;
                    for(let j = 0; j < 32; j++){
                        if(Math.sign(j & k) > 0 && comboReqs[j] > comboReqs[j - k]){
                            satisfied = false;  
                        }
                        colorSum += comboReqs[j] * Math.sign(j & k);
                        //comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                    }
                    if(satisfied && colorSum > 0){
                        for(let j = 0; j < 32 && satisfied; j++){
                            if(Math.sign(j & k) > 0){
                                comboReqs[j] = 0;
                                myLandTypes[j - k] += myLandTypes[j];
                                myLandTypes[j] = 0;
                            }
                        }
                    }
                }*/
            }
            return success;
        }

        // Like rLandTest, but divides the probability space over a number line of a given length
        // Instead of counting the exact proportions of each probability, it counts the number of "ticks" on the line within its slice of the line
        // Thus, it will give near-perfect estimations for probabilities that are well above the line's "resolution"
        // And for probabilities that are well below it, it functions more like a random sample
        function landTestUniformSample(cost, myLandTypes, numLands, myLandCount, i, pickedLands, min, max, comboReqs){
            if(Math.floor(max) == Math.floor(min)){
                // no ticks in range
                return 0;
            }
            if(Math.max(...comboReqs) <= 0){
                return Math.floor(max) - Math.floor(min);
            } 
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            iterations++;
            let success = 0;
            let span = max-min;
            let newMin = min;
            let newMax = min;
            let totalP = 0;
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    newMin = newMax;
                    newMax += p * span;
                    totalP += p;
                    success += landTestUniformSample(cost, myLandTypes, numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), newMin, newMax, structuredClone(comboReqs));
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
            }
            if(Math.abs(newMax - max) > 0.001){
                //console.log("Max: " + max + ", newMax: " + newMax + ", totalP: " + totalP * span);
            }
            return success;
        }

        function landAfford(pickedLands, cost){
            /*
            Frank discussed that to determine if it will meet a requirement with two different colors,
            A mana base needs to afford both of the individual color costs, as well as their combined value with any combination of the two colors
            I presume this extends to every permutation for spells with more colors
            */
            let comboReqs = getComboReqs(cost);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < pickedLands.length && comboReqs[i] > 0; j++){
                    comboReqs[i] -= Math.sign(i & pickedLands[j]); //if the color output overlaps with the requirement, decrement the requirement
                }
                if(comboReqs[i] > 0){
                    return 0;
                }
            }
            return 1;
        }

        function getComboReqs(cost){
            // Calculates the requirements for each combination of colors
            // ex. a card costing {1}{U}{W} would require 1 blue source, 1 white source, and 2 sources that can produce either blue or white.
            let comboReqs = new Array(32).fill(0);
            comboReqs[1] = cost.w;
            for(let i = 2; i < 4; i++){
                comboReqs[i] = comboReqs[i - 2] + cost.u;
            }
            for(let i = 4; i < 8; i++){
                comboReqs[i] = comboReqs[i - 4] + cost.b;
            }
            for(let i = 8; i < 16; i++){
                comboReqs[i] = comboReqs[i - 8] + cost.r;
            }
            for(let i = 16; i < 32; i++){
                comboReqs[i] = comboReqs[i - 16] + cost.g;
            }
            return comboReqs;
        }

        function landsToCast(cost){
            let pipReqs = [];
            if(cost.t == 1){
                pipReqs = oneDropDict.get(pipsToNum(cost)).slice();
            }
            else if(cost.t == 2){
                pipReqs = twoDropDict.get(pipsToNum(cost)).slice();
            }
            else{
                pipReqs = manaDict.get(pipsToNum(cost)).slice();
            }
            for(let i = 0; i < cost.t; i++){
                pipReqs[i] = 0;
            }
            return pipReqs;
        }

        function findLandIndex(source){
            let landIndex = 0;
            if(source.w){
                //pw += count * sourceMult;
                landIndex += 1;
            }
            if(source.u){
                //pu += count * sourceMult;
                landIndex += 2;
            }
            if(source.b){
                //pb += count * sourceMult;
                landIndex += 4;
            }
            if(source.r){
                //pr += count * sourceMult;
                landIndex += 8;
            }
            if(source.g){
                //pg += count * sourceMult;
                landIndex += 16;
            }
            return landIndex
        }

        function turnsToCast(cost){
            let landReqs = landsToCast(cost);
            let canCast = new Array(11);
            for(let i = 0; i < cost.t; i++){
                canCast[i] = 0;
            }
            for(let i = cost.t; i <= 10; i++){
                pCast = 0;
                let landDist = landsAtTurn(i);
                for(let lands = cost.t; lands <= 10; lands++){
                    //pCast += landReqs[lands] * drawType(99, landCount, i + 7, lands);
                    pCast += landReqs[lands] * landDist[lands];
                    //pCast += drawType(99, landCount, i + 7, lands);
                }
                //pCast += landReqs[10] * drawTypeMin(99, landCount, i + 7, 10);
                //pCast += drawTypeMin(99, landCount, i + 7, 10);
                canCast[i] = pCast
            }
            let pdf = new Array(11);
            pdf[0] = canCast[0];
            for(let i = 1; i < 10; i++){
                pdf[i] = canCast[i] - canCast[i-1];
            }
            pdf[10] = 1-canCast[9];
            return pdf;
        }

        function mean(pdf){
            let avg = 0;
            for(let i = 0; i < pdf.length; i++){
                avg += i * pdf[i];
            }
            return avg;
        }

        /*async function loadDict(){
            // Loads the dictionary of all cards ever from the server. This has to change later to scale up, but it works for now
            console.log('loading');
            var response = await fetch('http://localhost:8080');
            console.log('loaded');
            //var response = await fetch('./test.json');
            testDict = await response.json();
            console.log('processed');
        }*/

        async function loadDict(){
            // Loads the dictionary of all cards ever from the server. This has to change later to scale up, but it works for now
            L = document.getElementById('decklist').value;
            //console.log(L.toString());
            //dict = {"cards": L.toString()};
            console.log('loading');
            /*const request = new Request('http://localhost:8080', {
                method: "POST",
                //body: '{"foo": "bar"}',
                body: JSON.stringify(dict),
            });*/
            //var response = await fetch('http://localhost:8080/?cards=' + L);
            var response = await fetch('http://73.11.136.188:80/?cards=' + L);
            console.log('loaded');
            //var response = await fetch('./test.json');
            testDict = await response.json();

            cardList = L.split('\n');
            deckList = [];
            white = 0;
            blue = 0;
            black = 0;
            red = 0;
            green = 0;
            generic = 0;
            total = 0;
            let pw = 0; // produce white, produce blue, etc.
            let pu = 0;
            let pb = 0;
            let pr = 0;
            let pg = 0;

            landTypes = new Array(32).fill(0);
            landCount = 0;
            // read in cards from decklist
            for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
                if(cardList[c].includes(" (")){
                    cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" ("));
                }
                let name = cardList[c];
                let cut = 0
                while(name.charAt(cut) != ' '){
                    cut++;
                }
                let count = parseInt(name.substring(0,cut));
                name = name.substring(cut+1);
                let card = testDict[name];
                // Handle exceptions
                if(card == "NOT FOUND"){
                    addError("Error: \"" + name + "\" is not in our databse or Scryfall. This may be due to a typo");
                }
                else if(card == "FOUND"){
                    addError("Error: \"" + name + "\" is not in our database yet. Give us a few minutes to pull the latest data and try again");
                }
                else if(card == undefined){
                    addError("Error: \"" + name + "\" came back as undefined");
                }
                else{
                    let cost = card.mana_cost;
                    let colorCost = {w:0, u:0, b:0, r:0, g:0, c:0, t:0};
                    costList = cost.substring(1, cost.length-1).split('}{');
                    // read in individual pips from mana cost
                    for(let i = 0; i < costList.length; i++){
                        if(costList[i] == 'W'){
                            white += count;
                            total += count;
                            colorCost.w += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'U'){
                            blue += count;
                            total += count;
                            colorCost.u += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'B'){
                            black += count;
                            total += count;
                            colorCost.b += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'R'){
                            red += count;
                            total += count;
                            colorCost.r += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'G'){
                            green += count;
                            total += count;
                            colorCost.g += count;
                            colorCost.t += count;
                        } else if(parseInt(costList[i]) > 0){
                            generic += parseInt(costList[i]);
                            total += parseInt(costList[i]);
                            colorCost.c += count;
                            colorCost.t += parseInt(costList[i]);
                            //console.log(parseInt(costList[i]));
                        } else{
                            //console.log(name+costList[i]);
                        }
                    }
                    card.colorCost = colorCost;
                    let sourceMult = 1;
                    /*if(card.card_type.includes("creature")){
                        sourceMult = 0.5;
                    }else if (card.card_type.includes("artifact")){
                        sourceMult = 0.75;
                    }*/

                    // categorizing lands and incrementing category totals
                    if(card.card_type.includes("Land")){
                        if(card.mana_source.fetch){
                            deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
                            if(deckColors >= 3){
                                sourceMult = 0.67;
                            }
                        }
                        let landIndex = findLandIndex(card.mana_source);
                        // should it be 2/3 rainbow and 1/3 wastes?
                        landTypes[landIndex] += count * sourceMult;
                        landTypes[0] += count * (1-sourceMult);
                        landCount += count;
                        deckList.push(card);
                    } else{
                        deckList.push(card);
                    }
                }
                
                
            }
            //testLandRounding();
            deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
            if(deckColors >= 4){
                let configOptions = document.getElementById("approx-config");
                configOptions.hidden = false;
            }
            //if(deckColors >= 0){
            let computeButton = document.getElementById("compute-button");
            computeButton.disabled = false;
            //}
            console.log('processed');
            
            /*for(let i = 0; i < 5; i += 0.1){
                console.log(i + ": " + fact(i));
            }*/
            
        }

        function disableButton(){
            let computeButton = document.getElementById("compute-button");
            computeButton.disabled = true;
        }

        function addError(errorText){
            let error = document.createElement("div");
            error.innerText = errorText;
            error.classList.add("error-text");
            document.getElementById("analyzer-result-box").appendChild(error);
        }

        function tableRow(c1, c2, c3, type){
            newRow = document.createElement("tr");
            cell1 = document.createElement(type);
            cell1.innerText = c1;
            cell2 = document.createElement(type);
            cell2.innerText = c2;
            cell3 = document.createElement(type);
            cell3.innerText = c3;
            if(type == "td"){
                cell2.classList.add("table-num");
                cell3.classList.add("table-num");
            }
            newRow.appendChild(cell1);
            newRow.appendChild(cell2);
            newRow.appendChild(cell3);
            return newRow;
        }

        function deepAnal(){
            let textOut = "";
            manaDict = new Map();
            calcMullLands();

            /*console.log("lands: " + landCount);
            console.log(landTypes.slice());
            console.log(mullLands);
            console.log(landsAtTurn(1));*/
            let count = 1;
            
            //calculate for one drops based on mana from lands
            oneDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!oneDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        oneDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan one drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        landTypes[landIndex] += count * typeMult;
                        landCount += count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            //console.log(landsAtTurn(1));

            //calculate for two drops based on mana from lands and one drops
            twoDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!twoDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        twoDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan two drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        landTypes[landIndex] += count * typeMult;
                        landCount += count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            
            // calculate for 3 and above based on lands, 1, and 2
            for(let i = 0; i < deckList.length; i++){
                
                let pips = colorReqs(deckList[i].colorCost);
                let pipCode = pipsToNum(pips);
                if(!manaDict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    manaDict.set(pipCode, castDistro.slice());
                    //console.log(deckList[i].mana_cost + ": " + iterations);
                }
            }
            let costsCovered = new Set();
            let cmcOnCurve = 0;
            let totalCmcDelay = 0;
            let totalCmc = 0;
            for(let i = 0; i < deckList.length; i++){
                if(!deckList[i].card_type.includes("Land")){
                    let turnCastDist = turnsToCast(deckList[i].colorCost)
                    let cmc = deckList[i].colorCost.t;
                    let onCurveRate = turnCastDist[cmc];
                    let avgDelay = mean(turnCastDist) - deckList[i].colorCost.t;
                    cmcOnCurve += onCurveRate * cmc;
                    totalCmcDelay += avgDelay * cmc;
                    totalCmc += cmc;
                    if(!costsCovered.has(deckList[i].mana_cost)){
                        //result[textType] = result[textType] + "\n" + deckList[i].mana_cost + ": " + turnsToCast(deckList[i].colorCost).map(function(each_element){return each_element.toFixed(3)});
                        
                        //console.log(deckList[i].mana_cost);
                        
                        /*textOut = textOut + "\n" + deckList[i].mana_cost + ":";
                        textOut = textOut + " " + (onCurveRate * 100).toFixed(1) + "%, +";
                        textOut = textOut + (mean(turnCastDist) - deckList[i].colorCost.t).toFixed(3);*/
                        costsCovered.add(deckList[i].mana_cost);
                    }
                }
            }
            cmcOnCurve /= totalCmc;
            totalCmcDelay /= totalCmc;
            console.log("curve rate: " + cmcOnCurve);
            console.log("average delay: " + totalCmcDelay);
            return [cmcOnCurve, totalCmcDelay, textOut];
        }

        function cardFetch(){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                L = document.getElementById('decklist').value,
                result = document.getElementById('analyzer-result');
            
            approxColors = parseFloat(document.getElementById('approx-colors').value) || 10000;
            approxSamples = parseFloat(document.getElementById('approx-samples').value) || 5;
            //console.log("approxColors: " + approxColors);
            /*if(white > 0 && blue > 0 && black > 0 && red > 0 && green > 0){
                result[textType] = "It looks like you have a 5-color deck. Just a heads up, this might take a while";
            }*/
            //canAfford(deckList[0].colorCost);
            //result[textType] = "Metrics: Cast Rate, Average Delay";
            let landCountBackup = landCount;
            let landTypesBackup = landTypes.slice();
            //let keyList = Object.keys(deckList);
            let startTime = Date.now();

            let table = document.getElementById("output-table");
            if(table != null){
                table.remove();
            }
            table = document.createElement("table");
            table.id = "output-table";
            table.appendChild(tableRow("Manabase Variation", "Cast Rate", "Average Delay", "th"));

            let analResult = deepAnal();
            let baseRate = analResult[0];
            let baseDelay = analResult[1];
            table.appendChild(tableRow("Current Manabase", (baseRate * 100).toFixed(1) + "%", baseDelay.toFixed(3), "td"));
            //result[textType] = result[textType] + analResult[2];
            //result[textType] = result[textType] + '\nAverage: ' + (baseRate * 100).toFixed(1) + "%, +" + baseDelay.toFixed(3);

            let endTime = Date.now();
            if(endTime - startTime > 1500){
                console.log(`Execution time: ${endTime - startTime} ms`);
                //result[textType] = result[textType] + "\nLand impact analysis cancelled, predicted runtime too high";
                document.getElementById("analyzer-result-box").appendChild(table);
                addError("Error: Land impact analysis cancelled, predicted runtime too high");
                return;
            }

            landCount = landCountBackup + 1;
            landTypes = landTypesBackup.slice();
            landTypes[0] = landTypes[0] + 1;

            analResult = deepAnal();
            let wastesRate = analResult[0] - baseRate;
            let wastesDelay = analResult[1] - baseDelay;
            table.appendChild(tableRow("+1 Wastes", "+" + (wastesRate * 100).toFixed(2) + "%", wastesDelay.toFixed(3), "td"));
            //result[textType] = result[textType] + '\n+Wastes: +' + (wastesRate * 100).toFixed(2) + "%, " + wastesDelay.toFixed(4);

            //baseRate += wastesRate;
            //baseDelay += wastesDelay

            if(white > 0){
                landCount = landCountBackup + 1;
                landTypes = landTypesBackup.slice();
                landTypes[1] = landTypes[1] + 1;

                analResult = deepAnal();
                let newRate = analResult[0] - baseRate;
                let newDelay = analResult[1] - baseDelay;
                table.appendChild(tableRow("+1 Plains", "+" + (newRate * 100).toFixed(2) + "%", newDelay.toFixed(3), "td"));
                //result[textType] = result[textType] + '\n+White: +' + (newRate * 100).toFixed(2) + "%, " + newDelay.toFixed(4);
            }
            if(blue > 0){
                landCount = landCountBackup + 1;
                landTypes = landTypesBackup.slice();
                landTypes[2] = landTypes[2] + 1;

                analResult = deepAnal();
                let newRate = analResult[0] - baseRate;
                let newDelay = analResult[1] - baseDelay;
                table.appendChild(tableRow("+1 Island", "+" + (newRate * 100).toFixed(2) + "%", newDelay.toFixed(3), "td"));
                //result[textType] = result[textType] + '\n+Blue: +' + (newRate * 100).toFixed(2) + "%, " + newDelay.toFixed(4);
            }
            if(black > 0){
                landCount = landCountBackup + 1;
                landTypes = landTypesBackup.slice();
                landTypes[4] = landTypes[4] + 1;

                analResult = deepAnal();
                let newRate = analResult[0] - baseRate;
                let newDelay = analResult[1] - baseDelay;
                table.appendChild(tableRow("+1 Swamp", "+" + (newRate * 100).toFixed(2) + "%", newDelay.toFixed(3), "td"));
                //result[textType] = result[textType] + '\n+Black: +' + (newRate * 100).toFixed(2) + "%, " + newDelay.toFixed(4);
            }
            if(red > 0){
                landCount = landCountBackup + 1;
                landTypes = landTypesBackup.slice();
                landTypes[8] = landTypes[8] + 1;

                analResult = deepAnal();
                let newRate = analResult[0] - baseRate;
                let newDelay = analResult[1] - baseDelay;
                table.appendChild(tableRow("+1 Mountain", "+" + (newRate * 100).toFixed(2) + "%", newDelay.toFixed(3), "td"));
                //result[textType] = result[textType] + '\n+Red: +' + (newRate * 100).toFixed(2) + "%, " + newDelay.toFixed(4);
            }
            if(green > 0){
                landCount = landCountBackup + 1;
                landTypes = landTypesBackup.slice();
                landTypes[16] = landTypes[16] + 1;

                analResult = deepAnal();
                let newRate = analResult[0] - baseRate;
                let newDelay = analResult[1] - baseDelay;
                table.appendChild(tableRow("+1 Forest", "+" + (newRate * 100).toFixed(2) + "%", newDelay.toFixed(3), "td"));
                //result[textType] = result[textType] + '\n+Green: +' + (newRate * 100).toFixed(2) + "%, " + newDelay.toFixed(4);
            }
            landCount = landCountBackup ;
            landTypes = landTypesBackup;
            document.getElementById("analyzer-result-box").appendChild(table);
            //result[textType] = result[textType] + analResult[2];

            endTime = Date.now();
            console.log(`Execution time: ${endTime - startTime} ms`);

            //console.log(pipDist(deckList[0].colorCost));
            console.log(landTypes);
            //let manaCosts = "Generic: " + generic + "\nWhite: " + white + "\nBlue: " + blue + "\nBlack: " + black + "\nRed: " + red + "\nGreen: " + green;
            //let manaSources = "White: " + pw + "\nBlue: " + pu + "\nBlack: " + pb + "\nRed: " + pr + "\nGreen: " + pg;
            //result[textType] = "Costs:\n" + manaCosts + "\nSources:\n" + manaSources;
        }
    </script>
    <div class="analyzer" name="openinglands">
        <p class="title"> Manabase Analyzer</p>
        <p class="prompt"> Paste your decklist here </p>
        <textarea id="decklist" rows="10" cols="50">Paste your exported decklist here (format: '1 sol ring')</textarea>
        <div id="approx-config" hidden>
            <p>It looks like your deck has 4 or more colors. The time it takes to fully evaluate the support for a card increases exponentially with the number of colors in its mana cost. It might take a few seconds to complete the analysis. These settings can also help with this by using imperfect estimates for the most time-consuming cards:</p>
            <p class="prompt"> Estimate cards with <input type="text" id="approx-colors" value="5" style="width: 30px"> or more colors </p>
            
            <p class="prompt"> Estimation samples </p>
            <input type="text" id="approx-samples" value="10000">
        </div>
        <p>
            <input type="button" value="Load" onclick="loadDict()">
            <input type="button" id="compute-button" value="Compute" onclick="cardFetch()">
        </p>
        <div class="result-box" id="analyzer-result-box">
            <p id='analyzer-result' class="result-text"></p>
        </div>
    </div>
    <div style="float:left">
        <div class = "info-box" name="info">
            <p class="title"> How to Use</p>
            <ol type="1">
                <li>Paste your decklist into the entry box in the format [1 cardname]. You can get this using the "export to Arena" option on most deckbuilders and removing any extra lines that aren't in this format</li>
                <li>Click "Load" to retrieve the cards in your deck from our database</li>
                <li>Click "Compute" to analyze your deck</li>
            </ol>
            <p>This analyzer is built to test how well your deck's manabase can support its spells, and identify where it needs improvement. It does so by calculating 2 metrics:</p>
            <ol type="1">
                <li>Cast rate: For a spell with a mana value of X, what is the probability that you will have the mana available to cast it on turn X?</li>
                <li>Average Delay: On average, how many turns do you have to wait past turn X to be able to cast a spell? (this includes cases where it can be cast immediately)</li>
            </ol>
            <p>These two tend to be fairly closely related, with every 1% drop in cast rate leading to a roughly 0.03 turn increase in cast delay. However, cast delay can account for colors that have fewer sources in your deck and take longer to topdeck</p>
            <p>In general, a 90% cast rate or 0.3 average delay indicates that your deck has strong support from its manabase, while an 80% cast rate or 0.6 average delay is in need of improvement</p>
            <p>This analyzer recommends improvements by calculating these values for multiple variations on your manabase: one with an extra wastes, and one for each basic land type with an extra copy of that land</p>
            <p>The "+1 Wastes" variation is a good metric for how well your deck can support the mana values of your cards. If it's coming back with more than +1% cast rate and -0.03 average delay, your deck probably needs more lands in general</p>
            <p>The "+1 Basic" variations act as metric for how well your deck can support the color requirements of your cards. If the "+1 Plains" variation is only slightly better than the "+1 Wastes" variation, then your deck has the support for white it needs. But if it is a much larger imrpvement than "+1 Wastes", then your deck might need more white sources in general</p>
        </div>
        <div class = "warning-box" name="warning">
            <p class="angry-title"> Warning: This is an incomplete prototype</p>
            <p>While the basic functionality is in place, this tool does not have the capacity to accurately evaluate every type and source of mana present in Magic: the Gathering. 
                Here are some features that the current iteration does not know how to handle:</p>
            <ul>
                <li>Split Pips</li>
                <li>Colorless Mana</li>
                <li>Snow Mana</li>
                <li>Fetchable Duals/Triomes</li>
                <li>Using draw/scry/surveil to get more lands</li>
                <li>MDFC's (basic functionality is in place, but nuance is missing)</li>
                <li>Fetching in forms other than "Search your library for ___"</li>
                <li>Playing spells early due to ramp (any ramp is treated like extra lands)</li>
                <li>Ramp spells that can gain multiple sources (i.e. Cultivate)</li>
                <li>Choosing a ramp piece as a commander (i.e. <a href="https://www.youtube.com/watch?v=ceILMLrNCGw">Snail's Radha Deck</a>)</li>
                <li>Cards with very high mana value (10 is the absolute maximum, but 8 and above might get some strange results)</li>
            </ul>
            <p style="margin-bottom: 0px">In general, this analyzer is built to evaluate a traditional curve out (turn 1: 1-drop, turn 2: 2-drop, etc), and the less your deck's rollout looks like this, the less applicable this analysis will be</p>
        </div>
    </div>
</body>