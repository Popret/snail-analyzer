<head><base target="_blank">
    <link rel="shortcut icon" href="#">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* changing font for all text */
        body{
            font-family: Arial, Helvetica, sans-serif;
        }
        /* establishing types for different kinds of text used*/
        .title{
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .prompt{
            color: blue;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .result-text{
            color: green;
            display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
        }
        .result-number{
            font-weight: bold;
            margin: 0px;
            display: inline-block;
        }
        /* display box for calculators */
        .calculator{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            /*display: inline-block; /* let them show side by side */
        }
        /* display box for calculators */
        .analyzer{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            float:left;
            /*display: inline-block; /* let them show side by side */
        }
        .result-box{
            border: 1px solid black;
            background-color: white;
            padding: 5px;
        }
        .bar-graph{
            border: 1px solid black;
            padding: 5px;
            margin: 5px;
            min-height: 100px;
            min-width: 464px;
        }
        .graph-bar{
            display: inline-block;
            margin: 2px;
        }
        .miss-bar{
            border: 1px solid black;
            /*border-bottom: 0px;*/
            background-color: red;
            width: 40px;
        }
        .hit-bar{
            
            border: 1px solid black;
            background-color: #1166dd;
            width: 40px;
        }
        table {
            border: 2px solid rgb(80 80 80);
            border-collapse: collapse;
            border-spacing: 0;
            width: 100%;
        }
        .tab-table{
            border-top: none;
        }
        th {
            border: 1px solid rgb(120 120 120);
            /*border-top: none;*/
            /*outline: 1px solid rgb(120 120 120);*/
            background-color: #ddd;
            padding-top: 3px;
            padding-bottom: 3px;
            padding-left: 5px;
            padding-right: 5px;
        }
        td {
            border: 1px solid rgb(160 160 160);
            padding-top: 2px;
            padding-bottom: 2px;
            padding-left: 5px;
            padding-right: 5px;
        }
        .table-num{
            color: green;
            /*display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
            text-align: center;
        }
        .error-text{
            color: red;
        }
        .info-box{
            width: 800px;
            border: 0.5px solid black;
            background-color: #EEEEEE;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            /*float:left;*/
        }
        .angry-title{
            color: red;
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .warning-box{
            width: 800px;
            border: 1px solid black;
            background-color: mistyrose;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            float:left;
        }
        .tab {
            overflow: hidden;
            /*border: 1px solid #ccc;*/
            border:none;
            background-color: #f1f1f1;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            border-bottom: none;
        }

        /* Style the buttons inside the tab */
        .tab button {
            background-color: inherit;
            float: left;
            border: 1px solid black;
            border-bottom: none;
            outline: none;
            cursor: pointer;
            padding: 3px 7px;
            transition: 0.3s;
            font-size: 15px;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ccc;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ddd;
        }

        /* Style the tab content */
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body onload="disableButton()">
    <script>
        var testDict;

        var landTypes;
        var landCount;
        var iterations;
        var decklist;

        var manaDict;
        var oneDropDict;
        var twoDropDict;
        var mullLands;

        var white;
        var blue;
        var black;
        var red;
        var green;

        var approxColors;
        var approxSamples;
        var deckColors;

        var commander1;
        var commander2;
        var lastDecklist;

        var tapAnalDict;

        function fact(x){
            let y = x
            while(x>2){
                x=x-1
                y=y*x
            }
            if(y==0){y=y+1}
            return y
        }
    
        function choose(x,y){
            let z = (fact(x))/(fact(y)*fact(x-y))
            return z
        }

        // In cases where we have x!/y! and x>y, it is effectively equal to (y+1)(y+2)(y+3)...(x-2)(x-1)x
        // So we could save a lot of computation by simply calculating it as such
        function partialFact(y, x){
            let z = 1;
            while(x > y && x > 1){
                z = z * x;
                x = x - 1;
            }
            if(z==0){z=z+1}
            return z;
        }

        function quickChoose(x, y){
            let z = partialFact(Math.max(y, x-y), x)/fact(Math.min(y, x-y));
            return z;
        }
        
        function sum(arr){
            return arr.reduce((a, b) => a + b, 0);
        }

        // OLD ANALYSIS FUNCTIONS
        // These functions are here from the old calculators. I could probably remove some, but they're not hurting anything

        // These drawType functions are the foundation of most of the tools. They seem to be working well for me, but it might be good to be extra sure they're working right
        // given deck size, type count, draw size, and quota, calculates the chance of drawing exactly the quota of that type
        function drawType(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = quickChoose(allTotal-typeTotal, allDrawn-typeDrawn)*quickChoose(typeTotal, typeDrawn)/quickChoose(allTotal, allDrawn);
            return x;
        }

        function quickDrawType(allTotal, typeTotal, allDrawn, typeDrawn){
            //let x = choose(allTotal-typeTotal, allDrawn-typeDrawn)*choose(typeTotal, typeDrawn)/choose(allTotal, allDrawn);
            let x = (partialFact(allDrawn-typeDrawn, allDrawn) * partialFact(typeTotal - typeDrawn, typeTotal) * partialFact((allTotal - allDrawn) - (typeTotal - typeDrawn), allTotal - allDrawn)) / (partialFact(allTotal - typeTotal, allTotal) * fact(typeDrawn));
            return x;
        }

        // given deck size, type count, draw size, and type quota, run drawType for every amount >= quota and sum results
        // had to be altered to not attempt to draw more than exist in deck
        function drawTypeMin(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = 0;
            for(let i = typeDrawn; i <= allDrawn && i <= typeTotal; i++){
                x += drawType(allTotal, typeTotal, allDrawn, i);
            }
            return x;
        }

        // given deck size, 2 type counts, draw size, and 2 type quotas, find chance of meeting both quotas
        // walks through all satisfactory amounts of first type, and uses drawTypeMin to see if second type will meet quota
        // multiplies the two together to get the intersecting probability, and returns the sum
        // Since we already accounted for the number of type A being drawn, the second calculation is run with all type A removed from the deck
        function drawTwoTypeMin(allTotal, totalA, totalB, allDrawn, drawnA, drawnB){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTypeMin(allTotal-totalA, totalB, allDrawn-i, drawnB);
            }
            return x;
        }

        // like drawTwoTypeMin, but for three. The principle is the same
        function drawThreeTypeMin(allTotal, totalA, totalB, totalC, allDrawn, drawnA, drawnB, drawnC){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTwoTypeMin(allTotal - totalA, totalB, totalC, allDrawn-i, drawnB, drawnC);
            }
            return x;
        }
        
        // odds of drawing a card of a type by a certain turn, modified to use drawTypeMin
        function drawby(T,N){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                N = parseFloat(document.getElementById('N').value) || 0,
                T = parseFloat(document.getElementById('T').value) || 0,
                result = document.getElementById('result-text');
            //let x=(1-(choose(99-N,7+T)/choose(99,7+T)));
            let x = (drawTypeMin(99, N, T+7, 1));
            result[textType] = x.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:1});
        } 

        // NEW FUNCTIONS
        
        // converts the color costs of a card into an int from 0-31 representing 5 boolean values 
        function processCost(cost){
            return Math.sign(cost.w + cost.wu + cost.wb + cost.wr + cost.wg)
                 + 2 * Math.sign(cost.u + cost.wu + cost.ub + cost.ur + cost.ug)
                 + 4 * Math.sign(cost.b + cost.wb + cost.ub + cost.br + cost.bg)
                 + 8 * Math.sign(cost.r + cost.wr + cost.ur + cost.br + cost.rg)
                 + 16 * Math.sign(cost.g + cost.wg + cost.ug + cost.bg + cost.rg);
        }

        // count the number of colors in a card's mana cost
        function numColors(cost){
            return Math.sign(cost.w) + Math.sign(cost.u) + Math.sign(cost.b) + Math.sign(cost.r) + Math.sign(cost.g)
        }

        // extract the colored pips from a color cost
        function colorReqs(cost){
            return {
                w: cost.w,
                u: cost.u,
                b: cost.b,
                r: cost.r,
                g: cost.g,
                wu: cost.wu,
                wb: cost.wb,
                wr: cost.wr,
                wg: cost.wg,
                ub: cost.ub,
                ur: cost.ur,
                ug: cost.ug,
                br: cost.br,
                bg: cost.bg,
                rg: cost.rg
            };
        }

        // Encode the color pips of a mana cost as an integer using prime factors
        function pipsToNum(cost){
            return 2 ** cost.w * 3 ** cost.u * 5 ** cost.b * 7 ** cost.r * 11 ** cost.g
                * 13 ** cost.wu * 17 ** cost.wb * 19 ** cost.wr * 23 ** cost.wg * 29 ** cost.ub
                * 31 ** cost.ur * 37 ** cost.ug * 41 ** cost.br * 43 ** cost.bg * 47 ** cost.rg;
        }

        // Prime factorize an encoded cost to regain the pips
        function numToPips(num){
            if(num == 0){
                console.log("Something has gone very wrong");
                return 0;
            }
            let out = {
                w: 0,
                u: 0,
                b: 0,
                r: 0,
                g: 0
            };
            while(num % 2 == 0){
                out.w = out.w + 1;
                num /= 2;
            }
            while(num % 3 == 0){
                out.u = out.u + 1;
                num /= 3;
            }
            while(num % 5 == 0){
                out.b = out.b + 1;
                num /= 5;
            }
            while(num % 7 == 0){
                out.r = out.r + 1;
                num /= 7;
            }
            while(num % 11 == 0){
                out.g = out.g + 1;
                num /= 11;
            }
            return out;
        }

        // Simplify the categories of lands to only be relevant to a given color cost
        function landFilter(cost){
            let costCode = processCost(cost);
            let limitedLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                limitedLandTypes[i&costCode] += landTypes[i]
            }
            return limitedLandTypes;
        }

        // Calculate how lands contribute sources of various color combinations
        function sourcesFromLands(myLandTypes){
            let sources = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < 32; j++){
                    sources[i] += myLandTypes[j] * Math.sign(j & i); //limit the colors produced to the intersection between the colors needed and the actual production
                }
            }
            return sources;
        }

        // Take a land count and set of land categories that are not whole numbers, and convert them to a set of whole numbers
        // These whole numbers need to behave as closely as possible to how those fractional lands would have.
        // I am mainly trying to preserve the output on the color combination requirement array.
        // I am currently using a search function that might be a little bit expensive, but not excessively so compared to the resources used by the analysis itself
        function roundLands(myLandTypes){
            let myLandCount = sum(myLandTypes);
            let roundLandCount = Math.round(myLandCount);
            let floorLandTypes = new Array(32).fill(0);
            let floorLandCount = 0;
            // start with all lands rounded down, note how many to round back up.
            for(let i = 0; i < 32; i++){
                floorLandTypes[i] = Math.floor(myLandTypes[i]);
                floorLandCount += floorLandTypes[i];
            }
            let benchmark = sourcesFromLands(myLandTypes);
            let floorSources = sourcesFromLands(floorLandTypes);
            let error = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                error[i] = floorSources[i] - benchmark[i];
            }

            let result = roundSearch(floorLandTypes.slice(), myLandTypes, roundLandCount - floorLandCount, 0, error);
            let searchLandTypes = result[0];
            let reportedError = result[1];

            return searchLandTypes;
        }

        // The search function for roundLands
        // It goes through the lands, and for any that are not already a whole number, it branches and searches best solutions with it rounded up and rounded down
        // Recursively calls itself for each branch to find the best combination of rounding for the remaining unrounded numbers.
        function roundSearch(myRoundLands, myLandTypes, landsToAdd, i, error){
            // searches for next unrounded value
            while(myLandTypes[i] <= myRoundLands[i] && i < 31){
                i++;
            }
            if(landsToAdd < 1 || i > 31){
                // once it reaches the end of the array or runs out of extra lands to add, calculate error and return
                let sumSq = 0;
                for(let j = 0; j < 32; j++){
                    sumSq += error[j] ** 2;
                }
                return [myRoundLands, sumSq + landsToAdd * 100, error];
            }
            // calculate two sets of lands, one with and without land i rounded up, run search on both of them, and return the one with less error
            let set1 = roundSearch(myRoundLands.slice(), myLandTypes, landsToAdd, i + 1, error);
            let newRoundLands = myRoundLands.slice();
            newRoundLands[i] += 1;
            let newError = error.slice();
            for(let j = 0; j < 32; j++){
                newError[j] += Math.sign(j & i);
            }
            let set2 = roundSearch(newRoundLands, myLandTypes, landsToAdd - 1, i + 1, newError);
            if(set1[1] > set2[1]){
                return set2;
            }
            return set1;
        }

        // adds random noise to a manabase, then rounds it
        // not currently in use
        function testLandRounding(){
            let myLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                myLandTypes[i] = landTypes[i] + Math.random();
            }
            roundLands(myLandTypes);
        }

        // for a given set of color pips in a mana cost, generate a cdf for when a manabase is able to afford those colors
        function pipDist(cost){
            // override empty input fields with default values
            if(approxColors == undefined){
                approxColors = 5;
            }
            if(approxSamples == undefined){
                approxSamples = 10000;
            }
            // filter and round lands for given color combination
            let roundedLands = roundLands(landFilter(cost));
            let roundedLandCount = sum(roundedLands);

            let canCast = new Array(11);
            let comboReqs = getComboReqs(cost);
            // run 2 different versions of the analysis program, 1 that estimates for expensive cards, one that does the perfect computation for cheap cards.
            if(numColors(cost) < approxColors){
                for(let n = 0; n <= 10; n++){
                    result = rLandTest(cost, roundedLands, n, roundedLandCount, 31, [], 1, structuredClone(comboReqs));
                    canCast[n] = result;
                }
            }else{
                for(let n = 0; n <= 10; n++){
                    result = landTestUniformSample(cost, roundedLands, n, roundedLandCount, 31, [], 0, approxSamples, structuredClone(comboReqs));
                    canCast[n] = (result / approxSamples);
                }
            }

            return canCast;
        }
        // calculate the distribution of # of lands in hand after the player mulligans.
        // follows Frank Karsten's mulligan logic from his 2022 "How many sources?" article.
        function calcMullLands(){
            let openingDist = new Array(8);
            let mullDist = new Array(8);
            mullLands = new Array(8).fill(0);
            let mullAmount = 0;
            // distribution for a random hand
            for(let i = 0; i <= 7; i++){
                openingDist[i] = drawType(99, landCount, 7, i);
                mullDist[i] = openingDist[i];
            }

            //free mull, shoot for at least three
            mullAmount = mullDist[0] + mullDist[1] + mullDist[2] + mullDist[6] + mullDist[7];
            for(let i = 3; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            for(let i = 0; i <= 7; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            
            // Second mull, accept 2 if needed
            mullAmount = mullDist[0] + mullDist[1] + mullDist[6] + mullDist[7];
            for(let i = 2; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // shoot for 3 lands with our discards
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 7; i++){
                mullDist[i - 1] += openingDist[i] * mullAmount;
            }

            // After we discard to 6, the 6 and 7 land hands are now 5 and 6 land hands
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5] + mullDist[6];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard 2, once again shooting for 3 lands
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            mullDist[3] += openingDist[4] * mullAmount;
            for(let i = 5; i <= 7; i++){
                mullDist[i - 2] += openingDist[i] * mullAmount;
            }

            // After we discard to 5, we'll settle for at least one spell
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard to 4, 3 lands again
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 6; i++){
                mullDist[3] += openingDist[i] * mullAmount;
            }
            mullDist[4] += openingDist[7] * mullAmount;

            for(let i = 0; i < 7; i++){
                mullLands[i] += mullDist[i];
            }
            // only keep after 4
        }

        // 
        function landsAtTurn(turn){
            let landDist = new Array(11).fill(0);
            for(let startLands = 0; startLands < 7; startLands++){
                for(let drawnLands = 0; drawnLands <= turn; drawnLands++){
                    landDist[Math.min(startLands + drawnLands, 10)] += mullLands[startLands] * drawType(92 - turn, landCount - startLands, turn, drawnLands);
                }
            }
            return landDist;
        }

        // This is The Algorithm right here
        // Recursively testing different combinations of lands
        // Moving through the list of possible land types, if one is present in the deck, calculate the different possibilities for how many are in there.
        // Then adjust the numbers to feed back into rLandTest to account for the rest
        function rLandTest(cost, myLandTypes, numLands, myLandCount, i, pickedLands, scale, comboReqs){
            // check if mana requirements are already satisfied
            if(Math.max(...comboReqs) <= 0){
                return 1;
            } 
            // check if mana requirements are unreachable
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            let success = 0.0;
            let total = 0.0;
            iterations++;
            // scan forward through the land categories to find one thats in the deck
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            // check point of no return for each color
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            // run through the different numbers of the category of land that can be drawn, test their probability and recursively check with the remaining lands of each of them.
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    result = rLandTest(cost, myLandTypes.slice(), numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), p * scale, structuredClone(comboReqs));
                    success += p * result;
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
                // this next bit was some code for an optimization I had in mind
                // it did not work as planned but I would like to see if it could at some point in the future
                /*for(let k = 1; k < 32; k *= 2){
                    let satisfied = true;
                    let colorSum = 0;
                    for(let j = 0; j < 32; j++){
                        if(Math.sign(j & k) > 0 && comboReqs[j] > comboReqs[j - k]){
                            satisfied = false;  
                        }
                        colorSum += comboReqs[j] * Math.sign(j & k);
                        //comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                    }
                    if(satisfied && colorSum > 0){
                        for(let j = 0; j < 32 && satisfied; j++){
                            if(Math.sign(j & k) > 0){
                                comboReqs[j] = 0;
                                myLandTypes[j - k] += myLandTypes[j];
                                myLandTypes[j] = 0;
                            }
                        }
                    }
                }*/
            }
            return success;
        }

        // Like rLandTest, but divides the probability space over a number line of a given length
        // Instead of counting the exact proportions of each probability, it counts the number of "ticks" on the line within its slice of the line
        // Thus, it will give near-perfect estimations for probabilities that are well above the line's "resolution"
        // And for probabilities that are well below it, it functions more like a random sample
        function landTestUniformSample(cost, myLandTypes, numLands, myLandCount, i, pickedLands, min, max, comboReqs){
            if(Math.floor(max) == Math.floor(min)){
                // no ticks in range
                return 0;
            }
            if(Math.max(...comboReqs) <= 0){
                return Math.floor(max) - Math.floor(min);
            } 
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            iterations++;
            let success = 0;
            let span = max-min;
            let newMin = min;
            let newMax = min;
            let totalP = 0;
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    newMin = newMax;
                    newMax += p * span;
                    totalP += p;
                    success += landTestUniformSample(cost, myLandTypes, numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), newMin, newMax, structuredClone(comboReqs));
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i);
                }
            }
            return success;
        }

        // see if a given set of lands can affors a given set of color pips
        function landAfford(pickedLands, cost){
            /*
            Frank discussed that to determine if it will meet a requirement with two different colors,
            A mana base needs to afford both of the individual color costs, as well as their combined value with any combination of the two colors
            I presume this extends to every permutation for spells with more colors
            */
            let comboReqs = getComboReqs(cost);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < pickedLands.length && comboReqs[i] > 0; j++){
                    comboReqs[i] -= Math.sign(i & pickedLands[j]); //if the color output overlaps with the requirement, decrement the requirement
                }
                if(comboReqs[i] > 0){
                    return 0;
                }
            }
            return 1;
        }

        // Calculates the requirements for each combination of colors
            // ex. a card costing {1}{U}{W} would require 1 blue source, 1 white source, and 2 sources that can produce either blue or white.
        function getComboReqs(cost){
            let comboReqs = new Array(32).fill(0);
            comboReqs[1] = cost.w;
            for(let i = 2; i < 4; i++){
                comboReqs[i] = comboReqs[i - 2] + cost.u + cost.wu * Math.sign(i & 1);
            }
            for(let i = 4; i < 8; i++){
                comboReqs[i] = comboReqs[i - 4] + cost.b + cost.wb * Math.sign(i & 1) + cost.ub * Math.sign(i & 2);
            }
            for(let i = 8; i < 16; i++){
                comboReqs[i] = comboReqs[i - 8] + cost.r + cost.wr * Math.sign(i & 1) + cost.ur * Math.sign(i & 2) + cost.br * Math.sign(i & 4);
            }
            for(let i = 16; i < 32; i++){
                comboReqs[i] = comboReqs[i - 16] + cost.g + cost.wg * Math.sign(i & 1) + cost.ug * Math.sign(i & 2) + cost.bg * Math.sign(i & 4) + cost.rg * Math.sign(i & 8);
            }
            return comboReqs;
        }

        // using the stored pipdist dictionaries, get the distribution of how many lands are required to cast a spell
        function landsToCast(cost){
            let pipReqs = [];
            if(cost.t == 1){
                pipReqs = oneDropDict.get(pipsToNum(cost)).slice();
            }
            else if(cost.t == 2){
                pipReqs = twoDropDict.get(pipsToNum(cost)).slice();
            }
            else{
                let numfromPips = pipsToNum(cost)
                pipReqs = manaDict.get(numfromPips).slice();
            }
            for(let i = 0; i < cost.t; i++){
                pipReqs[i] = 0;
            }
            return pipReqs;
        }

        // encode a land's ability to produce each color as a boolean, stored in a 5-bit int
        function findLandIndex(source){
            let landIndex = 0;
            if(source.w){
                landIndex += 1;
            }
            if(source.u){
                landIndex += 2;
            }
            if(source.b){
                landIndex += 4;
            }
            if(source.r){
                landIndex += 8;
            }
            if(source.g){
                landIndex += 16;
            }
            return landIndex
        }

        // using the distributions of how many lands are required to cast a given spell and how many are available at a given turn, find the pdf on casting a spell on turns 1-10
        function turnsToCast(cost){
            let landReqs = landsToCast(cost);
            let canCast = new Array(11);
            for(let i = 0; i < cost.t; i++){
                canCast[i] = 0;
            }
            for(let i = cost.t; i <= 10; i++){
                pCast = 0;
                let landDist = landsAtTurn(i);
                for(let lands = cost.t; lands <= 10; lands++){
                    //pCast += landReqs[lands] * drawType(99, landCount, i + 7, lands);
                    pCast += landReqs[lands] * landDist[lands];
                    //pCast += drawType(99, landCount, i + 7, lands);
                }
                //pCast += landReqs[10] * drawTypeMin(99, landCount, i + 7, 10);
                //pCast += drawTypeMin(99, landCount, i + 7, 10);
                canCast[i] = pCast
            }
            let pdf = new Array(11);
            pdf[0] = canCast[0];
            for(let i = 1; i < 10; i++){
                pdf[i] = canCast[i] - canCast[i-1];
            }
            pdf[10] = 1-canCast[9];
            return pdf;
        }

        function mean(pdf){
            let avg = 0;
            for(let i = 0; i < pdf.length; i++){
                avg += i * pdf[i];
            }
            return avg;
        }

        // pings the server with the user's decklist, unpacks and stores the result
        async function loadDict(){
            
            //remove previous error messages
            clearError("load-result-box");

            L = document.getElementById('decklist').value;
            let sanitizedL = L.replace("&", "%26").replaceAll("1x", "1").replaceAll("2x", "2").replaceAll("3x", "3").replaceAll("4x", "4").replaceAll("5x", "5").replaceAll("6x", "6").replaceAll("7x", "7").replaceAll("8x", "8").replaceAll("9x", "9").replaceAll("0x", "0").replaceAll(/ \[.*\]/g, "").replaceAll(" *F*", "");
            if(sanitizedL != lastDecklist){
                console.log('loading');
                var response = await fetch('https://api.salubrioussnail.com/?cards=' + sanitizedL);
                console.log('loaded');
                testDict = await response.json();
            }
            lastDecklist = sanitizedL;

            cardList = sanitizedL.split('\n');
            deckList = [];
            white = 0;
            blue = 0;
            black = 0;
            red = 0;
            green = 0;
            generic = 0;
            total = 0;
            let pw = 0; // produce white, produce blue, etc.
            let pu = 0;
            let pb = 0;
            let pr = 0;
            let pg = 0;

            landTypes = new Array(32).fill(0);
            landCount = 0;
            let commanderName1 = (document.getElementById('commander-name-1').value) || "nocard";
            let commanderName2 = document.getElementById('commander-name-2').value || "nocard";
            let commander1found = 0;
            let commander2found = 0;
            
            // read in cards from decklist
            for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
                if(cardList[c].includes(" (")){
                    cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" ("));
                }
                if(cardList[c].includes(" *F*")){
                    cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" *F*"));
                }
                let name = cardList[c];
                let cut = 0
                while(name.charAt(cut) != ' '){
                    cut++;
                }
                let count = parseInt(name.substring(0,cut));
                name = name.substring(cut+1);
                let card = testDict[name];

                white += card.mana_cost.split("{W}").length - 1;
                blue += card.mana_cost.split("{U}").length - 1;
                black += card.mana_cost.split("{B}").length - 1;
                red += card.mana_cost.split("{R}").length - 1;
                green += card.mana_cost.split("{G}").length - 1;
            }

            for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
                let name = cardList[c];
                let cut = 0
                while(name.charAt(cut) != ' '){
                    cut++;
                }
                let count = parseInt(name.substring(0,cut));
                name = name.substring(cut+1);
                let card = testDict[name];
                // Handle exceptions
                if(card == "NOT FOUND"){
                    addError("load-result-box", "Error: \"" + name + "\" is not in our databse or Scryfall. This may be due to a typo");
                }
                else if(card == "FOUND"){
                    addError("load-result-box", "Error: \"" + name + "\" is not in our database yet. Give us a few minutes to pull the latest data and try again");
                }
                else if(card == undefined){
                    addError("load-result-box", "Error: \"" + name + "\" came back as undefined");
                }
                else{
                    card.name = name;
                    let cost = card.mana_cost;
                    let colorCost = {w:0, u:0, b:0, r:0, g:0, wu:0, wb:0, wr:0, wg:0, ub:0, ur:0, ug:0, br:0, bg:0, rg:0, c:0, t:0};
                    costList = cost.substring(1, cost.length-1).split('}{');
                    // read in individual pips from mana cost
                    for(let i = 0; i < costList.length; i++){
                        if(costList[i] == 'W'){
                            total += count;
                            colorCost.w += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'U'){
                            total += count;
                            colorCost.u += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'B'){
                            total += count;
                            colorCost.b += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'R'){
                            total += count;
                            colorCost.r += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'G'){
                            total += count;
                            colorCost.g += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'W/U'){
                            colorCost.wu += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'W/B'){
                            colorCost.wb += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'R/W'){
                            colorCost.wr += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'G/W'){
                            colorCost.wg += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'U/B'){
                            colorCost.ub += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'U/R'){
                            colorCost.ur += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'G/U'){
                            colorCost.ug += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'B/R'){
                            colorCost.br += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'B/G'){
                            colorCost.bg += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'R/G'){
                            colorCost.rg += count;
                            colorCost.t += count;
                        } else if(parseInt(costList[i]) > 0){
                            generic += parseInt(costList[i]);
                            total += parseInt(costList[i]);
                            colorCost.c += count;
                            colorCost.t += parseInt(costList[i]);
                        } else{
                            // there are edge cases, but I don't want to think about them at this very moment
                            //console.log(name+costList[i]);
                        }
                    }
                    card.colorCost = colorCost;
                    let sourceMult = 1;
                    card.count = count;

                    // categorizing lands and incrementing category totals
                    if(card.name.includes(commanderName1)){
                        commander1 = card;
                        console.log("commander 1: " + card.name);
                        commander1found += 1;
                    }
                    else if(card.name.includes(commanderName2)){
                        commander2 = card;
                        console.log("commander 2: " + card.name);
                        commander2found += 1;
                    }
                    else if(card.card_type.includes("Land")){
                        let deckColors = Math.sign(white) + Math.sign(blue) * 2 + Math.sign(black) * 4 + Math.sign(red) * 8 + Math.sign(green) * 16;
                        let landIndex = findLandIndex(card.mana_source) & deckColors;
                        // handle fetches
                        if(card.mana_source.fetch){
                            landTypes[landIndex] += count * 0.5;
                            let colors = Math.sign(landIndex & 1) + Math.sign(landIndex & 2) + Math.sign(landIndex & 4) + Math.sign(landIndex & 8) + Math.sign(landIndex & 16);
                            if(card.mana_source.w && white > 0){
                                landTypes[1] += count * 0.5 / colors;
                            }
                            if(card.mana_source.u && blue > 0){
                                landTypes[2] += count * 0.5 / colors;
                            }
                            if(card.mana_source.b && black > 0){
                                landTypes[4] += count * 0.5 / colors;
                            }
                            if(card.mana_source.r && red > 0){
                                landTypes[8] += count * 0.5 / colors;
                            }
                            if(card.mana_source.g && green > 0){
                                landTypes[16] += count * 0.5 / colors;
                            }
                            landCount += count;
                            deckList.push(card);
                            /*if(deckColors >= 3){
                                sourceMult = 0.67;
                            }*/
                        }
                        else{
                            landTypes[landIndex] += count * sourceMult;
                            landTypes[0] += count * (1-sourceMult);
                            landCount += count;
                            deckList.push(card);
                        }                        
                    } else{
                        deckList.push(card);
                    }
                }
                
                
            }
            if(commanderName1 != "nocard" && commander1found == 0){
                addError("load-result-box", "Error: the name \"" + commanderName1 + "\" did not match with any of the cards in your decklist. Double check the spelling and capitalization and try again");
            }
            if(commander1found > 1){
                addError("load-result-box", "Error: the name \"" + commanderName1 + "\" matched with multiple cards in your decklist. Try using a larger portion of the card's full name");
            }
            if(commanderName2 != "nocard" && commander2found == 0){
                addError("load-result-box", "Error: the name \"" + commanderName2 + "\" did not match with any of the cards in your decklist. Double check the spelling and capitalization and try again");
            }
            if(commander2found > 1){
                addError("load-result-box", "Error: the name \"" + commanderName2 + "\" matched with multiple cards in your decklist. Try using a larger portion of the card's full name");
            }

            // turn on estimation config options for players with 4 or 5 color decks
            deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
            if(deckColors >= 4){
                let configOptions = document.getElementById("approx-config");
                configOptions.hidden = false;
            }
            // deck is loaded, unlock compute button
            let computeButton = document.getElementById("color-compute-button");
            computeButton.disabled = false;
            computeButton = document.getElementById("tap-compute-button");
            computeButton.disabled = false;
            console.log('processed');
            let loadResult = document.getElementById("load-result");
            loadResult.innerText = "Deck loaded!";
        }

        // on startup, disable the compute button until the user loads their deck
        function disableButton(){
            let computeButton = document.getElementById("color-compute-button");
            computeButton.disabled = true;
            computeButton = document.getElementById("tap-compute-button");
            computeButton.disabled = true;
        }

        // for any error we want to display, print it to the output box
        function addError(resultBox, errorText){
            let error = document.createElement("div");
            error.innerText = errorText;
            error.classList.add("error-text");
            document.getElementById(resultBox).appendChild(error);
        }

        function clearError(resultBox){
            let result = document.getElementById(resultBox);
            let i = 0;
            while(i < result.children.length){
                let child = result.children[i];
                if(child.classList.contains("error-text")){
                    result.removeChild(child);
                }
                else{
                    i++;
                }
            }
        }

        // procedurally add rows to the analysis output table
        // type: "th" for table header, "td" for table data
        function tableRow(rowData, type){
            let newRow = document.createElement("tr");
            for(let i = 0; i < rowData.length; i++){
                let cell = document.createElement(type);
                cell.innerText = rowData[i];
                if(i > 0 && type == "td"){
                    cell.classList.add("table-num");
                }
                newRow.appendChild(cell);
            }
            return newRow;
        }

        // batching all those little functions up into one big "run the analysis" function
        function deepAnal(individualResults){
            let textOut = "";
            manaDict = new Map();
            calcMullLands();

            /*console.log("lands: " + landCount);
            console.log(landTypes.slice());
            console.log(mullLands);
            console.log(landsAtTurn(1));*/
            
            //calculate for one drops based on mana from lands
            oneDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!oneDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        oneDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan one drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        typeMult *= turnsToCast(deckList[i].colorCost)[1];
                        landTypes[landIndex] += deckList[i].count * typeMult;
                        landCount += deckList[i].count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            //console.log(landsAtTurn(1));

            //calculate for two drops based on mana from lands and one drops
            twoDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!twoDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        twoDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan two drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        typeMult *= turnsToCast(deckList[i].colorCost)[2];
                        landTypes[landIndex] += deckList[i].count * typeMult;
                        landCount += deckList[i].count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            
            // calculate for 3 and above based on lands, 1, and 2
            // maybe I should account for 3 on its own first. 3 mana ramp is definitely a thing
            for(let i = 0; i < deckList.length; i++){
                
                let pips = colorReqs(deckList[i].colorCost);
                let pipCode = pipsToNum(pips);
                if(!manaDict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    manaDict.set(pipCode, castDistro.slice());
                    //console.log(deckList[i].mana_cost + ": " + iterations);
                }
            }
            if(commander1){
                let pips = colorReqs(commander1.colorCost);
                let pipCode = pipsToNum(pips);
                if(!manaDict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    manaDict.set(pipCode, castDistro.slice());
                    //console.log(deckList[i].mana_cost + ": " + iterations);
                }
            }
            if(commander2){
                let pips = colorReqs(commander2.colorCost);
                let pipCode = pipsToNum(pips);
                if(!manaDict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    manaDict.set(pipCode, castDistro.slice());
                    //console.log(deckList[i].mana_cost + ": " + iterations);
                }
            }
            // now that all of the mana values are calculated for and added to the dictionary, add up all the relevant info and return it
            let costsCovered = new Set();
            let cmcOnCurve = 0;
            let totalCmcDelay = 0;
            let totalCmc = 0;
            let allCards = new Array();
            if(commander1){
                let weight = document.getElementById("cmdr1-weight").selectedOptions[0].value;
                let turnCastDist = turnsToCast(commander1.colorCost)
                let cmc = Math.min(commander1.colorCost.t, 10);
                let onCurveRate = turnCastDist[cmc];
                let avgDelay = mean(turnCastDist) - commander1.colorCost.t;
                cmcOnCurve += onCurveRate * cmc * weight;
                totalCmcDelay += avgDelay * cmc * weight;
                totalCmc += cmc * weight;
                if(!costsCovered.has(commander1.mana_cost)){
                    costsCovered.add(commander1.mana_cost);
                }
                allCards.push([commander1.name, onCurveRate, avgDelay]);
            }
            if(commander2){
                let weight = document.getElementById("cmdr2-weight").selectedOptions[0].value;
                let turnCastDist = turnsToCast(commander2.colorCost)
                let cmc = Math.min(commander2.colorCost.t, 10);
                let onCurveRate = turnCastDist[cmc];
                let avgDelay = mean(turnCastDist) - commander2.colorCost.t;
                cmcOnCurve += onCurveRate * cmc * weight;
                totalCmcDelay += avgDelay * cmc * weight;
                totalCmc += cmc * weight;
                if(!costsCovered.has(commander2.mana_cost)){
                    costsCovered.add(commander2.mana_cost);
                }
                allCards.push([commander2.name, onCurveRate, avgDelay]);
            }
            for(let i = 0; i < deckList.length; i++){
                if(!deckList[i].card_type.includes("Land")){
                    let turnCastDist = turnsToCast(deckList[i].colorCost)
                    let cmc = Math.min(deckList[i].colorCost.t, 10);
                    let onCurveRate = turnCastDist[cmc];
                    let avgDelay = mean(turnCastDist) - deckList[i].colorCost.t;
                    cmcOnCurve += onCurveRate * cmc;
                    totalCmcDelay += avgDelay * cmc;
                    totalCmc += cmc;
                    if(!costsCovered.has(deckList[i].mana_cost)){
                        costsCovered.add(deckList[i].mana_cost);
                        allCards.push([deckList[i].name, onCurveRate, avgDelay]);
                    }
                }
            }
            cmcOnCurve /= totalCmc;
            totalCmcDelay /= totalCmc;
            console.log("curve rate: " + cmcOnCurve);
            console.log("average delay: " + totalCmcDelay);
            if(individualResults){
                return [cmcOnCurve, totalCmcDelay, allCards];
            }
            return [cmcOnCurve, totalCmcDelay];
        }

        function testVariant(name, landDiff, baseRate, baseDelay){
            let landCountBackup = landCount;
            let landTypesBackup = landTypes.slice();
            for(let i = 0; i < 32; i++){
                landCount += landDiff[i];
                landTypes[i] += landDiff[i];
            }
            let analResult = deepAnal();
            let newRate = analResult[0] - baseRate;
            let newDelay = analResult[1] - baseDelay;
            let rateText;
            let delayText;
            if(newRate < 0){
                rateText = (newRate * 100).toFixed(2) + "%";
            }
            else{
                rateText = "+" + (newRate * 100).toFixed(2) + "%";
            }
            if(newDelay < 0){
                delayText = newDelay.toFixed(3);
            }
            else{
                delayText = "+" + newDelay.toFixed(3);
            }
            landCount = landCountBackup;
            landTypes = landTypesBackup.slice();
            return tableRow([name, rateText, delayText], "td");
        }

        function createDiff(indices){
            let diff = new Array(32).fill(0);
            for(let i = 0; i < indices.length; i++){
                diff[indices[i][0]] += indices[i][1];
            }
            return diff;
        }

        function cardCompare(a, b){
            if(commander1){
                if(a[0] == commander1.name){
                    return -1;
                }
                if(b[0] == commander1.name){
                    return 1;
                }
            }
            if(commander2){
                if(a[0] == commander2.name){
                    return -1;
                }
                if(b[0] == commander2.name){
                    return 1;
                }
            }
            if(a[2] < b[2]){
                return 1;
            }
            if(a[2] > b[2]){
                return -1;
            }
            return 0;
            
        }

        function reduceName(name, maxLength){
            if(name.length > maxLength){
                let newName = name;
                /*if(newName.includes(", ")){
                    newName = newName.substring(0, newName.indexOf(", "));
                }
                if(newName.includes(" of ")){
                    newName = newName.substring(0, newName.indexOf(" of "));
                }
                if(newName.includes(" the ")){
                    newName = newName.substring(0, newName.indexOf(" the "));
                }
                let matches = 0;
                for(let i = 0; i < cardList.length; i++){
                    if(cardList[i].includes(newName)){
                        matches += 1;
                    }
                }*/
                //if (matches != 1 || newName.length > maxLength - 3){
                    while(newName.length > maxLength - 3){
                        if(newName.includes(" ")){
                            newName = newName.substring(0, newName.lastIndexOf(" "));
                        }
                        else{
                            newName = newName.substring(0, maxLength - 3);
                        }
                    }
                //}
                newName = newName + "...";
                return newName;
            }
            return name;
        }
        function reduceMana(mana){
            return mana.replaceAll("{W}","W").replaceAll("{U}","U").replaceAll("{B}","B").replaceAll("{R}","R").replaceAll("{G}","G")
                .replace("{1}","1").replace("{2}","2").replace("{3}","3").replace("{4}","4").replace("{5}","5")
                .replace("{6}","6").replace("{7}","7").replace("{8}","8").replace("{9}","9");
        }

        function createTableTab(id, parent, buttonContents, tableContents){

            let outerDiv = document.getElementById(id);
            if(outerDiv != null){
                outerDiv.remove();
            }
            outerDiv = document.createElement("div");
            outerDiv.id = id;

            let buttonDiv = document.createElement("div");
            buttonDiv.classList.add("tab");

            for(let i = 0; i < buttonContents.length; i++){
                let newButton = document.createElement("button");
                newButton.innerText=buttonContents[i];
                newButton.addEventListener('click', function(evt){switchTableTab(evt.currentTarget.id)});
                newButton.onclick="switchTableTab(" + id + ", " + i + ")";
                newButton.id = id+"-button-"+i;
                newButton.classList.add(id+"-button");
                buttonDiv.appendChild(newButton);
            }

            outerDiv.appendChild(buttonDiv);

            for(let i = 0; i < tableContents.length; i++){
                let newTable = tableContents[i];
                newTable.id = id+"-table-"+i;
                newTable.style.border_top = "none";
                newTable.classList.add("tab-table");
                newTable.classList.add(id+"-table");
                outerDiv.appendChild(newTable);
            }

            document.getElementById(parent).appendChild(outerDiv);
            switchTableTab(id + "-button-0");
        }

        function switchTableTab(buttonId){
            let id = buttonId.substring(0,buttonId.indexOf("-button-"));
            let tabNum = buttonId.substring(buttonId.lastIndexOf("-")+1);
            let tables = document.getElementsByClassName(id + "-table");
            for(let i = 0; i < tables.length; i++){
                tables[i].style.display = "none";
            }

            let tablinks = document.getElementsByClassName(id + "-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(id+"-table-"+tabNum).style.display = "table";
            document.getElementById(buttonId).className += " active";
        }
        // this is the one tied to the compute button
        function colorTest(){
            // grab input from calculator
            var textType = Node.textContent ? 'textContent' : 'innerText',
                L = document.getElementById('decklist').value,
                result = document.getElementById('color-analyzer-result');
            
            approxColors = parseFloat(document.getElementById('approx-colors').value) || 10000;
            approxSamples = parseFloat(document.getElementById('approx-samples').value) || 5;
            let landCountBackup = landCount;
            let landTypesBackup = landTypes.slice();
            let startTime = Date.now();

            //remove previous errors
            clearError("color-analyzer-result-box");

            //create a fresh table for the analysis output
            let table = document.getElementById("color-output-table");
            if(table != null){
                table.remove();
            }
            table = document.createElement("table");
            table.id = "color-output-table";
            table.appendChild(tableRow(["Manabase Variation", "Cast Rate", "Average Delay"], "th"));

            // run analysis on base deck
            let analResult = deepAnal(true);
            let baseRate = analResult[0];
            let baseDelay = analResult[1];
            let allCards = analResult[2];
            table.appendChild(tableRow(["Current Manabase", (baseRate * 100).toFixed(1) + "%", baseDelay.toFixed(3)], "td"));

            let endTime = Date.now();
            if(endTime - startTime > 1500){
                console.log(`Execution time: ${endTime - startTime} ms`);
                //result[textType] = result[textType] + "\nLand impact analysis cancelled, predicted runtime too high";
                document.getElementById("color-analyzer-result-box").appendChild(table);
                addError("color-analyzer-result-box", "Error: Land impact analysis cancelled, predicted runtime too high");
                return;
            }

            landCount = landCountBackup;
            landTypes = landTypesBackup;

            // calculate for +1 wastes variant
            table.appendChild(testVariant("+1 Wastes", createDiff([[0, 1]]), baseRate, baseDelay));
            // calculate for variants with all the colors present in the deck
            if(white > 0){
                table.appendChild(testVariant("+1 Plains", createDiff([[1, 1]]), baseRate, baseDelay));
            }
            if(blue > 0){
                table.appendChild(testVariant("+1 Island", createDiff([[2, 1]]), baseRate, baseDelay));
            }
            if(black > 0){
                table.appendChild(testVariant("+1 Swamp", createDiff([[4, 1]]), baseRate, baseDelay));
            }
            if(red > 0){
                table.appendChild(testVariant("+1 Mountain", createDiff([[8, 1]]), baseRate, baseDelay));
            }
            if(green > 0){
                table.appendChild(testVariant("+1 Forest", createDiff([[16, 1]]), baseRate, baseDelay));
            }
            //document.getElementById("color-analyzer-result-box").appendChild(table);

            let cardTable = document.getElementById("color-card-table");
            if(cardTable != null){
                cardTable.remove();
            }
            cardTable = document.createElement("table");
            cardTable.id = "color-card-table";
            cardTable.appendChild(tableRow(["Card Name", "Cost", "Cast Rate", "Avg. Delay"], "th"));

            allCards = allCards.sort(cardCompare);

            for(let i = 0; i < 10; i++){
                cardTable.appendChild(tableRow([reduceName(allCards[i][0], 25), reduceMana(testDict[allCards[i][0]].mana_cost), (allCards[i][1] * 100).toFixed(1) + "%", allCards[i][2].toFixed(3)], "td"));
            }

            //document.getElementById("color-analyzer-result-box").appendChild(cardTable);

            createTableTab("color-test", "color-analyzer-result-box", ["Overall Performance", "Individual Cards"], [table, cardTable]);

            endTime = Date.now();
            console.log(`Execution time: ${endTime - startTime} ms`);

            console.log(landTypes);
        }

        // LAND CYCLE FUNCTIONS
        // these all need to be filled in with the calculations necessary for their relevant cycle of lands
        // a few things to keep in mind while working on these:
        // - if you are looking for the number of lands at a given turn, make sure to start with the turn 0 mulligan distribution. You may need to call calcMullLands() at the beginning of tapTest()
        // - lands can start in the opening hand or be drawn later into the game. Make sure to account for both
        // - these should ideally be able to work considering any number of turns after the start of the game. Let's call this n

        function pTapFast(turns){
            // Enters untapped if you control 2 or fewer other lands
            // If it's drawn before turn 4 (p = 10/n+7), it's untapped
            // If it's drawn on or after turn 4, (p = n-3/n+7), check for the probability that the player has only drawn 2 or fewer other lands by that point.
            return 0.5;
        }

        function pTapSlow(turns){
            // Enters untapped if you control 2 or more other lands
            // If it's drawn before turn three (p = 9/n+7), check for the probability that the player will draw enough other lands to play first.
            // If it's drawn on or after turn 3 (p = n-2/n+7), check for the probability that the player has drawn two or more other lands by that point.
            return 0.5;
        }

        function pTapCheck(types, turns){
            // Enters untapped if you control a card of one of a list of specified types.
            // For this category of check lands, I think it would make sense to model it with the probability that the player draws a card of the accepted types before they have no other lands left
            // The required process will likely look something like this:
            // - check each card in the deck against the list of accepted types and see how many fit one of them. Also note the divide between land and nonland cards
            // - if the types are found on nonland cards, then calculate the probability of of one of them appearing in a random selection of 7 nonland cards
            // - if the types are found on land cards, then find the distribution of how many other lands the player will draw before they are forced to play this one
            // - combine that with the probabilities of one of the accepted land types being among the other lands
            // NOTE: for these lands, the array of accepted types is stored in source.fastInfo
            // most of it includes the exact types that will appear on cards' type lines, but there are a few that just say "legendary creature", and one that just says "legendary green creature"
            return 0.5;
        }

        function pTapTango(turns){
            // Enters untapped if you control 2 or more basic lands
            // like pTapCheck, but you check the probability of 2 basics instead of 1
            return 0.5;
        }

        function pTapWilds(types, turns){
            // For the cycle of "3 or more other [basic type]" lands from eldraine
            // Like pTapCheck, but you use the probability of three instead of 1
            return 0.5;
        }

        function pTapReveal(types, turns){
            // For the lands that want you to reveal a card of a certain subtype to enter untapped
            // this would work like pTapCheck, but there's now the possibility of playing the card before you draw the land and then everything's all fucked up
            // good luck lmao
            return 0.5;
        }

        function pTap(source, turns){
            if(source.fast == true){
                return 0;
            }
            else if(source.fast == false){
                return 1;
            }
            else if(source.fast == "fast"){
                return pTapFast(turns);
            }
            else if(source.fast == "slow"){
                return pTapSlow(turns);
            }
            else if(source.fast == "check"){
                return pTapCheck(source.fastInfo, turns);
            }
            else if(source.fast == "tango"){
                return pTapTango(turns);
            }
            else if(source.fast == "wilds"){
                return pTapWilds(source.fastInfo, turns);
            }
            else if(source.fast == "reveal"){
                return pTapReveal(source.fastInfo, turns);
            }
            else if(source.fast == "triskaidekadual"){
                return 0.8; //Since this is outside the deck, we just have to use a fixed approximation. I'm thinking it won't happen often though
            }
            else if(source.fast == "unless"){
                addError("tap-analyzer-result-box", "You appear to be using one of those new-fangled land cycles that we haven't even heard of. Go bother @rudeavocado in on the Salubrious Sail discord server so he can add it to this tool");
                return 0.5;
            }
            else{
                addError("tap-analyzer-result-box", "Got string \"" + source.fast + "\" and freaked out");
                return 0.5;
            }
        }

        function findCurveDensity(tapTotal, turns){
            let nonland = 0;
            let curve = new Array(11).fill(0);
            let maxMana = 0;
            for(let i = 0; i < deckList.length; i++){
                if(!deckList[i].card_type.includes("Land")){
                    if(deckList[i].colorCost.t > 10){
                        curve[10]++;
                        nonland++;
                    }
                    else{
                        curve[deckList[i].colorCost.t]++;
                        nonland++;
                    }
                    if(deckList[i].colorCost.t > maxMana){
                        maxMana = deckList[i].colorCost.t;
                    }
                }
            }
            curve.length = maxMana + 1;
            //console.log(curve);
            calcMullLands();
            /*let value = 0;
            for(let i = 1; i <= turns; i++){
                value += drawTypeMin(99, curve[i], 7+i, 1);
            }
            console.log(value / turns);*/
            let start = Date.now();
            let value = tapTestWrapper(tapTotal, curve, nonland, turns, 100000);
            console.log("Elapsed time: " + (Date.now()-start) + "ms");
            //console.log(value);
            return(value);
        }

        // wrapper for tapTest
        // run rTapTest() on every combination of tapped and untapped lands that can be drawn and compile results
        function tapTestWrapper(tapTotal, curve, nonland, maxTurns, span){
            let value = 0;
            let deckLands = [tapTotal, landCount - tapTotal];
            let myMullLands = landsAtTurn(1); // post-mulligan land distribution plus first draw
            iterations = 0;
            tapAnalDict = new Map();
            let min = 0;
            // iterate through each number of lands that can be drawn
            for(let i = 0; i <= 6; i++){
                // iterate through each number of drawn lands that enter tapped
                for(let j = 0; j <= i && j <= tapTotal; j++){
                    let max = min + span * myMullLands[i] * drawType(landCount, tapTotal, i, j);
                    value += rTapTest(0, [j, i-j], new Array(curve.length), [deckLands[0] - j, deckLands[1] - i + j], nonland, curve, landCount + nonland - 8, 8-i, nonland - 8 + i, maxTurns - 1, min, max);
                    min = max;
                }
            }
            console.log("Iterations: " + iterations);
            return value / span;
        }

        // given a deck's curve, number of lands, number of tap lands, and the contents of the current hand, calculate how much mana worth of spells the deck will be able to cast within a certain number of turns
        // This explores all the possible options and adds them together based on their relative probabilities
        // in order to save computation, this uses a "wildcard" system for cards that are too expensive to cast, treating them as a single category when drawing cards
        // when more mana becomes available, it uses drawType() to determine how many of the wildcards it can now afford.
        function rTapTest(landsDown, handLands, handCurve, deckLands, deckNL, deckCurve, deckRemaining, wildcards, wildPicks, turnsRemaining, min, max){
            /*let inputToKey = [landsDown, handLands, handCurve, deckLands, deckNL, deckCurve, deckRemaining, wildcards, wildPicks, turnsRemaining].toString();
            if(tapAnalDict.has(inputToKey)){
                return tapAnalDict.get(inputToKey);
            }
            else{*/
            let span = max - min;
            if(Math.floor(max) == Math.floor(min)){
                return 0;
            }
            if(turnsRemaining == undefined){
                console.log("Uh-oh");
            }
            iterations++;
            // the mana we can work with is based on the number of lands played already plus our ability to play an untapped land
            let mana = landsDown + Math.sign(handLands[1]);
            // If this gives us access to cards that we couldn't previously afford, we need to see how many of them we have
            // This can jump by 2 if we played a tap land last turn and an untapped land this turn
            for(let cmc = 1; cmc <= mana; cmc++){
                // if we do not have an entry in the curve array for a mana value, that means that it is included in the wildcards and needs to be brought out
                if(handCurve[cmc] == undefined){
                    // branch based on number of cards of a given cmc drawn
                    let value = 0;
                    let commanders = 0;
                    if(commander1 != undefined && commander1.colorCost.t == cmc){
                        commanders += 1;
                    }
                    if(commander2 != undefined && commander2.colorCost.t == cmc){
                        commanders += 1;
                    }
                    let newMin = min;
                    for(let i = Math.max(0, deckCurve[cmc] - wildPicks); i <= wildcards && i <= deckCurve[cmc]; i++){
                        let newDeckCurve = deckCurve.slice();
                        newDeckCurve[cmc] -= i;
                        let newHandCurve = handCurve.slice();
                        newHandCurve[cmc] = commanders + i;
                        let newMax = newMin + span * drawType(wildPicks + wildcards, deckCurve[cmc], wildcards, i);
                        value += rTapTest(landsDown, handLands.slice(), newHandCurve, deckLands.slice(), deckNL - i, newDeckCurve, deckRemaining, wildcards - i, wildPicks - newDeckCurve[cmc], turnsRemaining, newMin, newMax);
                        newMin = newMax;
                        //value += (turnsRemaining + 1) * drawType(wildPicks, deckCurve[mana], wildcards, i);
                    }
                    return value;
                }
            }
            let check = mana;
            let value = 0;
            // spend mana as we are able
            for(; check > 0; check--){
                while(handCurve[check] > 0 && mana - check >= 0){
                    handCurve[check] -= 1;
                    mana -= check;
                    value += check; // keep track of mana spent
                }
            }

            // if we used more mana than we had at the start of the turn, then we had to have played an untapped land
            if(value > landsDown){
                handLands[1]--;
                landsDown++;
            }
            else if (handLands[0] > 0){ // Otherwise, play a tap land if we have one
                handLands[0]--;
                landsDown++;
            }
            else if (handLands[1] > 0){ // Otherwise, play an untapped land
                handLands[1]--;
                landsDown++;
            }
            value *= (turnsRemaining + 1) * (Math.floor(max) - Math.floor(min));
            // branch based on card drawn next
            if(turnsRemaining > 0){
                // if we can draw lands of either type, draw and calculate the probability
                let newMin = min;
                if(deckLands[0] > 0){
                    let newMax = newMin + span * (deckLands[0] / deckRemaining);
                    value += rTapTest(landsDown, [handLands[0] + 1, handLands[1]], handCurve.slice(), [deckLands[0] - 1, deckLands[1]], deckNL, deckCurve.slice(), deckRemaining - 1, wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
                if(deckLands[1] > 0){
                    let newMax = newMin + span * (deckLands[1] / deckRemaining);
                    value += rTapTest(landsDown, [handLands[0], handLands[1] + 1], handCurve.slice(), [deckLands[0], deckLands[1] - 1], deckNL, deckCurve.slice(), deckRemaining - 1, wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
                // for the cards that are no longer wildcards, we need to test whether they have been drawn individually
                for(let i = 1; handCurve[i] != undefined; i++){
                    if(deckCurve[i] > 0){
                        let newDeckCurve = deckCurve.slice();
                        newDeckCurve[i] -= 1;
                        let newHandCurve = handCurve.slice();
                        newHandCurve[i] += 1;
                        let newMax = newMin + span * (deckCurve[i] / deckRemaining);
                        value += rTapTest(landsDown, handLands.slice(), newHandCurve, deckLands.slice(), deckNL - 1, newDeckCurve, deckRemaining - 1, wildcards, wildPicks, turnsRemaining - 1, newMin, newMax);
                        newMin = newMax;
                    }
                }
                // draw wildcards
                if(wildPicks > 0){
                    let newMax = newMin + span * (wildPicks / deckRemaining);
                    value += rTapTest(landsDown, handLands.slice(), handCurve.slice(), deckLands.slice(), deckNL, deckCurve.slice(), deckRemaining - 1, wildcards + 1, wildPicks - 1, turnsRemaining - 1, newMin, newMax);
                    newMin = newMax;
                }
            }
            //tapAnalDict.set(inputToKey,value);
            return value;
            //}
        }

        function tapTest(){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                result = document.getElementById('tap-analyzer-result'),
                turns = parseFloat(document.getElementById('tap-turns').value) || 5;
            
            //remove previous errors
            clearError("tap-analyzer-result-box");
            
            let tapTotal = 0;
            let untapTotal = 0;
            let landCount = 0;
            let table = document.getElementById("tap-test-table")
            if(table != null){
                table.remove();
            }
            table = document.createElement("table");
            table.id = "tap-test-table";
            table.appendChild(tableRow(["Land", "Tap Chance"], "th"));
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].card_type.includes("Land")){
                    let tap = pTap(deckList[i].mana_source, turns);
                    tapTotal += deckList[i].count * tap;
                    untapTotal += deckList[i].count * (1 - tap);
                    landCount += deckList[i].count;
                    if(tap > 0 && tap < 1){
                        table.appendChild(tableRow([deckList[i].name, (tap * 100).toFixed(1) + "%"], "td"));
                    }
                }
            }
            let actualPerformance = findCurveDensity(Math.round(tapTotal), turns);
            let oneLessTapPerformance = findCurveDensity(Math.max(Math.round(tapTotal - 1), 0), turns);
            let allUntappedPerformance = findCurveDensity(0, turns);
            result.innerText = "Your lands enter tapped " + (tapTotal * 100 / landCount).toFixed(1) + 
                "% of the time\nThis makes your curve-outs " + ((1 - (actualPerformance / allUntappedPerformance)) * 100).toFixed(1) + 
                "% less effective\nThis would be a " + ((1 - (oneLessTapPerformance / allUntappedPerformance)) * 100).toFixed(1) + "% reduction if you replaced a tap land with an untapped land";
            document.getElementById("tap-analyzer-result-box").appendChild(table);
        }
    </script>
    <div class="analyzer" name="deckEntry">
        <p class="prompt"> Paste your decklist here </p>
        <textarea id="decklist" rows="10" cols="50" placeholder="Paste your exported decklist here (format: '1 sol ring')"></textarea>
        <p class="prompt"> Name of commander(s) </p>
        <p><input type="text" id="commander-name-1" placeholder="Commander">
        <input type="text" id="commander-name-2" placeholder="Partner/Companion"></p>
        <label for="commander">How important is your commander to your deck?</label>
        <select name="commander" id="cmdr1-weight">
            <option value="10">Just another card</option>
            <option value="20">A nice bonus for a deck that is still functional without it</option>
            <option value="30">A major boost for a deck that would struggle without it</option>
            <option value="50">A critical piece of a deck that would fall flat without it</option>
        </select>
        <br><br>
        <label for="partner">How important is your partner/companion to your deck?</label>
        <select name="partner" id="cmdr2-weight">
            <option value="10">Just another card</option>
            <option value="20">A nice bonus for a deck that is still functional without it</option>
            <option value="30">A major boost for a deck that would struggle without it</option>
            <option value="50">A critical piece of a deck that would fall flat without it</option>
        </select>
        <p>
            <input type="button" value="Load" onclick="loadDict()">
        </p>
        <div class="result-box" id="load-result-box">
            <p id='load-result' class="result-text"></p>
        </div>
    </div>
    <div class="analyzer" name="colorCalc">
        <p class="title"> Color Analyzer</p>
        <div id="approx-config" hidden>
            <p>It looks like your deck has 4 or more colors. The time it takes to fully evaluate the support for a card increases exponentially with the number of colors in its mana cost. It might take a few seconds to complete the analysis. These settings can also help with this by using imperfect estimates for the most time-consuming cards:</p>
            <p class="prompt"> Estimate cards with <input type="text" id="approx-colors" value="5" style="width: 30px"> or more colors </p>
            
            <p class="prompt"> Estimation samples </p>
            <input type="text" id="approx-samples" value="10000">
        </div>
        <p>
            <input type="button" id="color-compute-button" value="Compute" onclick="colorTest()">
        </p>    
        <div class="result-box" id="color-analyzer-result-box">
            <p id='color-analyzer-result' class="result-text"></p>
        </div>
    </div>
    <div class="analyzer" name="tapCalc">
        <p class="title"> Tap Analyzer</p>
        <p class="prompt"> Include first <input type="text" id="tap-turns" value="7" style="width: 30px"> turns in calculations</p>
        <p>
            <input type="button" id="tap-compute-button" value="Compute" onclick="tapTest()">
        </p>    
        <div class="result-box" id="tap-analyzer-result-box">
            <p id='tap-analyzer-result' class="result-text"></p>
        </div>
    </div>
    <!-- These info boxes can probably just be on the website itself. This is an embed after all
    <div style="float:left">
        <div class = "info-box" name="info">
            <p class="title"> How to Use</p>
            <ol type="1">
                <li>Paste your decklist into the entry box in the format [1 cardname]. You can get this using the "export to Arena" option on most deckbuilders and removing any extra lines that aren't in this format</li>
                <li>Click "Load" to retrieve the cards in your deck from our database</li>
                <li>Click "Compute" to analyze your deck</li>
            </ol>
            <p>This analyzer is built to test how well your deck's manabase can support its spells, and identify where it needs improvement. It does so by calculating 2 metrics:</p>
            <ol type="1">
                <li>Cast rate: For a spell with a mana value of X, what is the probability that you will have the mana available to cast it on turn X?</li>
                <li>Average Delay: On average, how many turns do you have to wait past turn X to be able to cast a spell? (this includes cases where it can be cast immediately)</li>
            </ol>
            <p>These two tend to be fairly closely related, with every 1% drop in cast rate leading to a roughly 0.03 turn increase in cast delay. However, cast delay can account for colors that have fewer sources in your deck and take longer to topdeck</p>
            <p>In general, a 90% cast rate or 0.3 average delay indicates that your deck has strong support from its manabase, while an 80% cast rate or 0.6 average delay is in need of improvement</p>
            <p>This analyzer recommends improvements by calculating these values for multiple variations on your manabase: one with an extra wastes, and one for each basic land type with an extra copy of that land</p>
            <p>The "+1 Wastes" variation is a good metric for how well your deck can support the mana values of your cards. If it's coming back with more than +1% cast rate and -0.03 average delay, your deck probably needs more lands in general</p>
            <p>The "+1 Basic" variations act as metric for how well your deck can support the color requirements of your cards. If the "+1 Plains" variation is only slightly better than the "+1 Wastes" variation, then your deck has the support for white it needs. But if it is a much larger imrpvement than "+1 Wastes", then your deck might need more white sources in general</p>
        </div>
        <div class = "warning-box" name="warning">
            <p class="angry-title"> Warning: This is an incomplete prototype</p>
            <p>While the basic functionality is in place, this tool does not have the capacity to accurately evaluate every type and source of mana present in Magic: the Gathering. 
                Here are some features that the current iteration does not know how to handle:</p>
            <ul>
                <li>Split Pips</li>
                <li>Colorless Mana</li>
                <li>Snow Mana</li>
                <li>Fetchable Duals/Triomes</li>
                <li>Using draw/scry/surveil to get more lands</li>
                <li>MDFC's (basic functionality is in place, but nuance is missing)</li>
                <li>Fetching in forms other than "Search your library for ___"</li>
                <li>Playing spells early due to ramp (any ramp is treated like extra lands)</li>
                <li>Ramp spells that can gain multiple sources (i.e. Cultivate)</li>
                <li>Choosing a ramp piece as a commander (i.e. <a href="https://www.youtube.com/watch?v=ceILMLrNCGw">Snail's Radha Deck</a>)</li>
                <li>Cards with very high mana value (10 is the absolute maximum, but 8 and above might get some strange results)</li>
            </ul>
            <p style="margin-bottom: 0px">In general, this analyzer is built to evaluate a traditional curve out (turn 1: 1-drop, turn 2: 2-drop, etc), and the less your deck's rollout looks like this, the less applicable this analysis will be</p>
        </div>
    </div> -->
</body>
