<head><base target="_blank">
    <link rel="shortcut icon" href="#">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* changing font for all text */
        body{
            font-family: Arial, Helvetica, sans-serif;
        }
        /* establishing types for different kinds of text used*/
        .title{
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .prompt{
            color: blue;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .result-text{
            color: green;
            display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
        }
        .result-number{
            font-weight: bold;
            margin: 0px;
            display: inline-block;
        }
        /* display box for calculators */
        .calculator{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            /*display: inline-block; /* let them show side by side */
        }
        /* display box for calculators */
        .analyzer{
            background-color: #EEEEEE;
            border: 2px solid black;
            border-radius: 10px; /* round corners */
            padding: 10px; /* giving text room */
            margin: 10px; /* spacing calculators apart */
            width: 500px; /* change if needed,  */
            float:left;
            /*display: inline-block; /* let them show side by side */
        }
        .result-box{
            border: 1px solid black;
            background-color: white;
            padding: 5px;
        }
        .bar-graph{
            border: 1px solid black;
            padding: 5px;
            margin: 5px;
            min-height: 100px;
            min-width: 464px;
        }
        .graph-bar{
            display: inline-block;
            margin: 2px;
        }
        .miss-bar{
            border: 1px solid black;
            /*border-bottom: 0px;*/
            background-color: red;
            width: 40px;
        }
        .hit-bar{
            
            border: 1px solid black;
            background-color: #1166dd;
            width: 40px;
        }
        table {
            border: 2px solid rgb(80 80 80);
            border-collapse: collapse;
            border-spacing: 0;
        }
        th {
            border: 1px solid rgb(120 120 120);
            padding-top: 3px;
            padding-bottom: 3px;
            padding-left: 5px;
            padding-right: 5px;
        }
        td {
            border: 1px solid rgb(160 160 160);
            padding-top: 2px;
            padding-bottom: 2px;
            padding-left: 5px;
            padding-right: 5px;
        }
        .table-num{
            color: green;
            /*display: inline-block; /* allows this and result to display in one line */
            margin: 0px;
            text-align: center;
        }
        .error-text{
            color: red;
        }
        .info-box{
            width: 800px;
            border: 1px solid black;
            background-color: #EEEEEE;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            /*float:left;*/
        }
        .angry-title{
            color: red;
            font-weight: bold;
            margin: 0px; /* altering text spacing */
        }
        .warning-box{
            width: 800px;
            border: 1px solid black;
            background-color: mistyrose;
            padding: 10px; /* giving text room */
            margin: 5px; 
            /*margin-left: 0px;*/
            /*display: inline-block;*/
            float:left;
        }
    </style>
</head>
<body onload="disableButton()">
    <script>
        var testDict;

        var landTypes;
        var landCount;
        var iterations;
        var decklist;

        var manaDict;
        var oneDropDict;
        var twoDropDict;
        var mullLands;

        var white;
        var blue;
        var black;
        var red;
        var green;

        var approxColors;
        var approxSamples;
        var deckColors;

        function fact(x){
            let y = x
            while(x>2){
                x=x-1
                y=y*x
            }
            if(y==0){y=y+1}
            return y
        }
    
        function choose(x,y){
            let z = (fact(x))/(fact(y)*fact(x-y))
            return z
        }

        // In cases where we have x!/y! and x>y, it is effectively equal to (y+1)(y+2)(y+3)...(x-2)(x-1)x
        // So we could save a lot of computation by simply calculating it as such
        function partialFact(y, x){
            let z = 1;
            while(x > y && x > 1){
                z = z * x;
                x = x - 1;
            }
            if(z==0){z=z+1}
            return z;
        }

        function quickChoose(x, y){
            let z = partialFact(Math.max(y, x-y), x)/fact(Math.min(y, x-y));
            return z;
        }
        
        function sum(arr){
            return arr.reduce((a, b) => a + b, 0);
        }

        // OLD ANALYSIS FUNCTIONS
        // These functions are here from the old calculators. I could probably remove some, but they're not hurting anything

        // These drawType functions are the foundation of most of the tools. They seem to be working well for me, but it might be good to be extra sure they're working right
        // given deck size, type count, draw size, and quota, calculates the chance of drawing exactly the quota of that type
        function drawType(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = quickChoose(allTotal-typeTotal, allDrawn-typeDrawn)*quickChoose(typeTotal, typeDrawn)/quickChoose(allTotal, allDrawn);
            return x;
        }

        function quickDrawType(allTotal, typeTotal, allDrawn, typeDrawn){
            //let x = choose(allTotal-typeTotal, allDrawn-typeDrawn)*choose(typeTotal, typeDrawn)/choose(allTotal, allDrawn);
            let x = (partialFact(allDrawn-typeDrawn, allDrawn) * partialFact(typeTotal - typeDrawn, typeTotal) * partialFact((allTotal - allDrawn) - (typeTotal - typeDrawn), allTotal - allDrawn)) / (partialFact(allTotal - typeTotal, allTotal) * fact(typeDrawn));
            return x;
        }

        // given deck size, type count, draw size, and type quota, run drawType for every amount >= quota and sum results
        // had to be altered to not attempt to draw more than exist in deck
        function drawTypeMin(allTotal, typeTotal, allDrawn, typeDrawn){
            let x = 0;
            for(let i = typeDrawn; i <= allDrawn && i <= typeTotal; i++){
                x += drawType(allTotal, typeTotal, allDrawn, i);
            }
            return x;
        }

        // given deck size, 2 type counts, draw size, and 2 type quotas, find chance of meeting both quotas
        // walks through all satisfactory amounts of first type, and uses drawTypeMin to see if second type will meet quota
        // multiplies the two together to get the intersecting probability, and returns the sum
        // Since we already accounted for the number of type A being drawn, the second calculation is run with all type A removed from the deck
        function drawTwoTypeMin(allTotal, totalA, totalB, allDrawn, drawnA, drawnB){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTypeMin(allTotal-totalA, totalB, allDrawn-i, drawnB);
            }
            return x;
        }

        // like drawTwoTypeMin, but for three. The principle is the same
        function drawThreeTypeMin(allTotal, totalA, totalB, totalC, allDrawn, drawnA, drawnB, drawnC){
            let x = 0;
            for(let i = drawnA; i <= allDrawn && i <= totalA; i++){
                x += drawType(allTotal, totalA, allDrawn, i)*drawTwoTypeMin(allTotal - totalA, totalB, totalC, allDrawn-i, drawnB, drawnC);
            }
            return x;
        }
        
        // odds of drawing a card of a type by a certain turn, modified to use drawTypeMin
        function drawby(T,N){
            var textType = Node.textContent ? 'textContent' : 'innerText',
                N = parseFloat(document.getElementById('N').value) || 0,
                T = parseFloat(document.getElementById('T').value) || 0,
                result = document.getElementById('result-text');
            //let x=(1-(choose(99-N,7+T)/choose(99,7+T)));
            let x = (drawTypeMin(99, N, T+7, 1));
            result[textType] = x.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:1});
        } 

        // NEW FUNCTIONS
        
        // converts the color costs of a card into an int from 0-31 representing 5 boolean values 
        function processCost(cost){
            return Math.sign(cost.w) + 2 * Math.sign(cost.u) + 4 * Math.sign(cost.b) + 8 * Math.sign(cost.r) + 16 * Math.sign(cost.g);
        }

        // count the number of colors in a card's mana cost
        function numColors(cost){
            return Math.sign(cost.w) + Math.sign(cost.u) + Math.sign(cost.b) + Math.sign(cost.r) + Math.sign(cost.g)
        }

        // extract the colored pips from a color cost
        function colorReqs(cost){
            return {
                w: cost.w,
                u: cost.u,
                b: cost.b,
                r: cost.r,
                g: cost.g
            };
        }

        // Encode the color pips of a mana cost as an integer using prime factors
        function pipsToNum(cost){
            return 2 ** cost.w * 3 ** cost.u * 5 ** cost.b * 7 ** cost.r * 11 ** cost.g;
        }

        // Prime factorize an encoded cost to regain the pips
        function numToPips(num){
            if(num == 0){
                console.log("Something has gone very wrong");
                return 0;
            }
            let out = {
                w: 0,
                u: 0,
                b: 0,
                r: 0,
                g: 0
            };
            while(num % 2 == 0){
                out.w = out.w + 1;
                num /= 2;
            }
            while(num % 3 == 0){
                out.u = out.u + 1;
                num /= 3;
            }
            while(num % 5 == 0){
                out.b = out.b + 1;
                num /= 5;
            }
            while(num % 7 == 0){
                out.r = out.r + 1;
                num /= 7;
            }
            while(num % 11 == 0){
                out.g = out.g + 1;
                num /= 11;
            }
            return out;
        }

        // Simplify the categories of lands to only be relevant to a given color cost
        function landFilter(cost){
            let costCode = processCost(cost);
            let limitedLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                limitedLandTypes[i&costCode] += landTypes[i]
            }
            return limitedLandTypes;
        }

        // Calculate how lands contribute sources of various color combinations
        function sourcesFromLands(myLandTypes){
            let sources = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < 32; j++){
                    sources[i] += myLandTypes[j] * Math.sign(j & i); //limit the colors produced to the intersection between the colors needed and the actual production
                }
            }
            return sources;
        }

        // Take a land count and set of land categories that are not whole numbers, and convert them to a set of whole numbers
        // These whole numbers need to behave as closely as possible to how those fractional lands would have.
        // I am mainly trying to preserve the output on the color combination requirement array.
        // I am currently using a search function that might be a little bit expensive, but not excessively so compared to the resources used by the analysis itself
        function roundLands(myLandTypes){
            let myLandCount = sum(myLandTypes);
            let roundLandCount = Math.round(myLandCount);
            let floorLandTypes = new Array(32).fill(0);
            let floorLandCount = 0;
            // start with all lands rounded down, note how many to round back up.
            for(let i = 0; i < 32; i++){
                floorLandTypes[i] = Math.floor(myLandTypes[i]);
                floorLandCount += floorLandTypes[i];
            }
            let benchmark = sourcesFromLands(myLandTypes);
            let floorSources = sourcesFromLands(floorLandTypes);
            let error = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                error[i] = floorSources[i] - benchmark[i];
            }

            let result = roundSearch(floorLandTypes.slice(), myLandTypes, roundLandCount - floorLandCount, 0, error);
            let searchLandTypes = result[0];
            let reportedError = result[1];

            return searchLandTypes;
        }

        // The search function for roundLands
        // It goes through the lands, and for any that are not already a whole number, it branches and searches best solutions with it rounded up and rounded down
        // Recursively calls itself for each branch to find the best combination of rounding for the remaining unrounded numbers.
        function roundSearch(myRoundLands, myLandTypes, landsToAdd, i, error){
            // searches for next unrounded value
            while(myLandTypes[i] <= myRoundLands[i] && i < 31){
                i++;
            }
            if(landsToAdd < 1 || i > 31){
                // once it reaches the end of the array or runs out of extra lands to add, calculate error and return
                let sumSq = 0;
                for(let j = 0; j < 32; j++){
                    sumSq += error[j] ** 2;
                }
                return [myRoundLands, sumSq + landsToAdd * 100, error];
            }
            // calculate two sets of lands, one with and without land i rounded up, run search on both of them, and return the one with less error
            let set1 = roundSearch(myRoundLands.slice(), myLandTypes, landsToAdd, i + 1, error);
            let newRoundLands = myRoundLands.slice();
            newRoundLands[i] += 1;
            let newError = error.slice();
            for(let j = 0; j < 32; j++){
                newError[j] += Math.sign(j & i);
            }
            let set2 = roundSearch(newRoundLands, myLandTypes, landsToAdd - 1, i + 1, newError);
            if(set1[1] > set2[1]){
                return set2;
            }
            return set1;
        }

        // adds random noise to a manabase, then rounds it
        // not currently in use
        function testLandRounding(){
            let myLandTypes = new Array(32).fill(0);
            for(let i = 0; i < 32; i++){
                myLandTypes[i] = landTypes[i] + Math.random();
            }
            roundLands(myLandTypes);
        }

        // for a given set of color pips in a mana cost, generate a cdf for when a manabase is able to afford those colors
        function pipDist(cost){
            // override empty input fields with default values
            if(approxColors == undefined){
                approxColors = 5;
            }
            if(approxSamples == undefined){
                approxSamples = 10000;
            }
            // filter and round lands for given color combination
            let roundedLands = roundLands(landFilter(cost));
            let roundedLandCount = sum(roundedLands);

            let canCast = new Array(11);
            let comboReqs = getComboReqs(cost);
            // run 2 different versions of the analysis program, 1 that estimates for expensive cards, one that does the perfect computation for cheap cards.
            if(numColors(cost) < approxColors){
                for(let n = 0; n <= 10; n++){
                    result = rLandTest(cost, roundedLands, n, roundedLandCount, 31, [], 1, structuredClone(comboReqs));
                    canCast[n] = result;
                }
            }else{
                for(let n = 0; n <= 10; n++){
                    result = landTestUniformSample(cost, roundedLands, n, roundedLandCount, 31, [], 0, approxSamples, structuredClone(comboReqs));
                    canCast[n] = (result / approxSamples);
                }
            }

            return canCast;
        }
        // calculate the distribution of # of lands in hand after the player mulligans.
        // follows Frank Karsten's mulligan logic from his 2022 "How many sources?" article.
        function calcMullLands(){
            let openingDist = new Array(8);
            let mullDist = new Array(8);
            mullLands = new Array(8).fill(0);
            let mullAmount = 0;
            // distribution for a random hand
            for(let i = 0; i <= 7; i++){
                openingDist[i] = drawType(99, landCount, 7, i);
                mullDist[i] = openingDist[i];
            }

            //free mull, shoot for at least three
            mullAmount = mullDist[0] + mullDist[1] + mullDist[2] + mullDist[6] + mullDist[7];
            for(let i = 3; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            for(let i = 0; i <= 7; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            
            // Second mull, accept 2 if needed
            mullAmount = mullDist[0] + mullDist[1] + mullDist[6] + mullDist[7];
            for(let i = 2; i < 6; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // shoot for 3 lands with our discards
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 7; i++){
                mullDist[i - 1] += openingDist[i] * mullAmount;
            }

            // After we discard to 6, the 6 and 7 land hands are now 5 and 6 land hands
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5] + mullDist[6];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard 2, once again shooting for 3 lands
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            mullDist[3] += openingDist[4] * mullAmount;
            for(let i = 5; i <= 7; i++){
                mullDist[i - 2] += openingDist[i] * mullAmount;
            }

            // After we discard to 5, we'll settle for at least one spell
            mullAmount = mullDist[0] + mullDist[1] + mullDist[5];
            for(let i = 2; i < 5; i++){
                mullLands[i] += mullDist[i];
            }
            mullDist = new Array(8).fill(0);

            // discard to 4, 3 lands again
            for(let i = 0; i <= 3; i++){
                mullDist[i] += openingDist[i] * mullAmount;
            }
            for(let i = 4; i <= 6; i++){
                mullDist[3] += openingDist[i] * mullAmount;
            }
            mullDist[4] += openingDist[7] * mullAmount;

            for(let i = 0; i < 7; i++){
                mullLands[i] += mullDist[i];
            }
            // only keep after 4
        }

        // 
        function landsAtTurn(turn){
            let landDist = new Array(11).fill(0);
            for(let startLands = 0; startLands < 7; startLands++){
                for(let drawnLands = 0; drawnLands <= turn; drawnLands++){
                    landDist[Math.min(startLands + drawnLands, 10)] += mullLands[startLands] * drawType(92 - turn, landCount - startLands, turn, drawnLands);
                }
            }
            return landDist;
        }

        // This is The Algorithm right here
        // Recursively testing different combinations of lands
        // Moving through the list of possible land types, if one is present in the deck, calculate the different possibilities for how many are in there.
        // Then adjust the numbers to feed back into rLandTest to account for the rest
        function rLandTest(cost, myLandTypes, numLands, myLandCount, i, pickedLands, scale, comboReqs){
            // check if mana requirements are already satisfied
            if(Math.max(...comboReqs) <= 0){
                return 1;
            } 
            // check if mana requirements are unreachable
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            let success = 0.0;
            let total = 0.0;
            iterations++;
            // scan forward through the land categories to find one thats in the deck
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            // check point of no return for each color
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            // run through the different numbers of the category of land that can be drawn, test their probability and recursively check with the remaining lands of each of them.
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    result = rLandTest(cost, myLandTypes.slice(), numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), p * scale, structuredClone(comboReqs));
                    success += p * result;
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                }
                // this next bit was some code for an optimization I had in mind
                // it did not work as planned but I would like to see if it could at some point in the future
                /*for(let k = 1; k < 32; k *= 2){
                    let satisfied = true;
                    let colorSum = 0;
                    for(let j = 0; j < 32; j++){
                        if(Math.sign(j & k) > 0 && comboReqs[j] > comboReqs[j - k]){
                            satisfied = false;  
                        }
                        colorSum += comboReqs[j] * Math.sign(j & k);
                        //comboReqs[j] -= Math.sign(j & i); //if the color output overlaps with the requirement, decrement the requirement
                    }
                    if(satisfied && colorSum > 0){
                        for(let j = 0; j < 32 && satisfied; j++){
                            if(Math.sign(j & k) > 0){
                                comboReqs[j] = 0;
                                myLandTypes[j - k] += myLandTypes[j];
                                myLandTypes[j] = 0;
                            }
                        }
                    }
                }*/
            }
            return success;
        }

        // Like rLandTest, but divides the probability space over a number line of a given length
        // Instead of counting the exact proportions of each probability, it counts the number of "ticks" on the line within its slice of the line
        // Thus, it will give near-perfect estimations for probabilities that are well above the line's "resolution"
        // And for probabilities that are well below it, it functions more like a random sample
        function landTestUniformSample(cost, myLandTypes, numLands, myLandCount, i, pickedLands, min, max, comboReqs){
            if(Math.floor(max) == Math.floor(min)){
                // no ticks in range
                return 0;
            }
            if(Math.max(...comboReqs) <= 0){
                return Math.floor(max) - Math.floor(min);
            } 
            if(Math.max(...comboReqs) > numLands){
                return 0;
            }
            while(i > 0 && myLandTypes[i] == 0){
                i--;
            }
            if(i < 16 && comboReqs[16] > 0){
                return 0;
            }
            if(i < 8 && comboReqs[8] > 0){
                return 0;
            }
            if(i < 4 && comboReqs[4] > 0){
                return 0;
            }
            if(i < 2 && comboReqs[2] > 0){
                return 0;
            }
            iterations++;
            let success = 0;
            let span = max-min;
            let newMin = min;
            let newMax = min;
            let totalP = 0;
            for(let n = 0; n <= numLands && n <= myLandTypes[i]; n++){
                let p = drawType(myLandCount, myLandTypes[i], numLands, n);
                if(p > 0){
                    newMin = newMax;
                    newMax += p * span;
                    totalP += p;
                    success += landTestUniformSample(cost, myLandTypes, numLands - n, myLandCount - myLandTypes[i], i-1, structuredClone(pickedLands), newMin, newMax, structuredClone(comboReqs));
                }
                pickedLands.push(i);
                for(let j = 0; j < 32; j++){
                    comboReqs[j] -= Math.sign(j & i);
                }
            }
            return success;
        }

        // see if a given set of lands can affors a given set of color pips
        function landAfford(pickedLands, cost){
            /*
            Frank discussed that to determine if it will meet a requirement with two different colors,
            A mana base needs to afford both of the individual color costs, as well as their combined value with any combination of the two colors
            I presume this extends to every permutation for spells with more colors
            */
            let comboReqs = getComboReqs(cost);
            for(let i = 0; i < 32; i++){
                for(let j = 0; j < pickedLands.length && comboReqs[i] > 0; j++){
                    comboReqs[i] -= Math.sign(i & pickedLands[j]); //if the color output overlaps with the requirement, decrement the requirement
                }
                if(comboReqs[i] > 0){
                    return 0;
                }
            }
            return 1;
        }

        // Calculates the requirements for each combination of colors
            // ex. a card costing {1}{U}{W} would require 1 blue source, 1 white source, and 2 sources that can produce either blue or white.
        function getComboReqs(cost){
            let comboReqs = new Array(32).fill(0);
            comboReqs[1] = cost.w;
            for(let i = 2; i < 4; i++){
                comboReqs[i] = comboReqs[i - 2] + cost.u;
            }
            for(let i = 4; i < 8; i++){
                comboReqs[i] = comboReqs[i - 4] + cost.b;
            }
            for(let i = 8; i < 16; i++){
                comboReqs[i] = comboReqs[i - 8] + cost.r;
            }
            for(let i = 16; i < 32; i++){
                comboReqs[i] = comboReqs[i - 16] + cost.g;
            }
            return comboReqs;
        }

        // using the stored pipdist dictionaries, get the distribution of how many lands are required to cast a spell
        function landsToCast(cost){
            let pipReqs = [];
            if(cost.t == 1){
                pipReqs = oneDropDict.get(pipsToNum(cost)).slice();
            }
            else if(cost.t == 2){
                pipReqs = twoDropDict.get(pipsToNum(cost)).slice();
            }
            else{
                pipReqs = manaDict.get(pipsToNum(cost)).slice();
            }
            for(let i = 0; i < cost.t; i++){
                pipReqs[i] = 0;
            }
            return pipReqs;
        }

        // encode a land's ability to produce each color as a boolean, stored in a 5-bit int
        function findLandIndex(source){
            let landIndex = 0;
            if(source.w){
                landIndex += 1;
            }
            if(source.u){
                landIndex += 2;
            }
            if(source.b){
                landIndex += 4;
            }
            if(source.r){
                landIndex += 8;
            }
            if(source.g){
                landIndex += 16;
            }
            return landIndex
        }

        // using the distributions of how many lands are required to cast a given spell and how many are available at a given turn, find the pdf on casting a spell on turns 1-10
        function turnsToCast(cost){
            let landReqs = landsToCast(cost);
            let canCast = new Array(11);
            for(let i = 0; i < cost.t; i++){
                canCast[i] = 0;
            }
            for(let i = cost.t; i <= 10; i++){
                pCast = 0;
                let landDist = landsAtTurn(i);
                for(let lands = cost.t; lands <= 10; lands++){
                    //pCast += landReqs[lands] * drawType(99, landCount, i + 7, lands);
                    pCast += landReqs[lands] * landDist[lands];
                    //pCast += drawType(99, landCount, i + 7, lands);
                }
                //pCast += landReqs[10] * drawTypeMin(99, landCount, i + 7, 10);
                //pCast += drawTypeMin(99, landCount, i + 7, 10);
                canCast[i] = pCast
            }
            let pdf = new Array(11);
            pdf[0] = canCast[0];
            for(let i = 1; i < 10; i++){
                pdf[i] = canCast[i] - canCast[i-1];
            }
            pdf[10] = 1-canCast[9];
            return pdf;
        }

        function mean(pdf){
            let avg = 0;
            for(let i = 0; i < pdf.length; i++){
                avg += i * pdf[i];
            }
            return avg;
        }

        // pings the server with the user's decklist, unpacks and stores the result
        async function loadDict(){
            L = document.getElementById('decklist').value;
            console.log('loading');
            var response = await fetch('https://api.salubrioussnail.com/?cards=' + L);
            console.log('loaded');
            testDict = await response.json();

            cardList = L.split('\n');
            deckList = [];
            white = 0;
            blue = 0;
            black = 0;
            red = 0;
            green = 0;
            generic = 0;
            total = 0;
            let pw = 0; // produce white, produce blue, etc.
            let pu = 0;
            let pb = 0;
            let pr = 0;
            let pg = 0;

            landTypes = new Array(32).fill(0);
            landCount = 0;
            // read in cards from decklist
            for(let c = 0; c < cardList.length && cardList[c] != ""; c++){
                if(cardList[c].includes(" (")){
                    cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" ("));
                }
                if(cardList[c].includes(" *F*")){
                    cardList[c] = cardList[c].substring(0, cardList[c].indexOf(" *F*"));
                }
                let name = cardList[c];
                let cut = 0
                while(name.charAt(cut) != ' '){
                    cut++;
                }
                let count = parseInt(name.substring(0,cut));
                name = name.substring(cut+1);
                let card = testDict[name];
                // Handle exceptions
                if(card == "NOT FOUND"){
                    addError("Error: \"" + name + "\" is not in our databse or Scryfall. This may be due to a typo");
                }
                else if(card == "FOUND"){
                    addError("Error: \"" + name + "\" is not in our database yet. Give us a few minutes to pull the latest data and try again");
                }
                else if(card == undefined){
                    addError("Error: \"" + name + "\" came back as undefined");
                }
                else{
                    let cost = card.mana_cost;
                    let colorCost = {w:0, u:0, b:0, r:0, g:0, c:0, t:0};
                    costList = cost.substring(1, cost.length-1).split('}{');
                    // read in individual pips from mana cost
                    for(let i = 0; i < costList.length; i++){
                        if(costList[i] == 'W'){
                            white += count;
                            total += count;
                            colorCost.w += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'U'){
                            blue += count;
                            total += count;
                            colorCost.u += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'B'){
                            black += count;
                            total += count;
                            colorCost.b += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'R'){
                            red += count;
                            total += count;
                            colorCost.r += count;
                            colorCost.t += count;
                        } else if(costList[i] == 'G'){
                            green += count;
                            total += count;
                            colorCost.g += count;
                            colorCost.t += count;
                        } else if(parseInt(costList[i]) > 0){
                            generic += parseInt(costList[i]);
                            total += parseInt(costList[i]);
                            colorCost.c += count;
                            colorCost.t += parseInt(costList[i]);
                        } else{
                            // there are edge cases, but I don't want to think about them at this very moment
                            //console.log(name+costList[i]);
                        }
                    }
                    card.colorCost = colorCost;
                    let sourceMult = 1;

                    // categorizing lands and incrementing category totals
                    if(card.card_type.includes("Land")){
                        // handle fetches
                        if(card.mana_source.fetch){
                            deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
                            if(deckColors >= 3){
                                sourceMult = 0.67;
                            }
                        }
                        let landIndex = findLandIndex(card.mana_source);
                        landTypes[landIndex] += count * sourceMult;
                        landTypes[0] += count * (1-sourceMult);
                        landCount += count;
                        deckList.push(card);
                    } else{
                        deckList.push(card);
                    }
                }
                
                
            }
            // turn on estimation config options for players with 4 or 5 color decks
            deckColors = Math.sign(white) + Math.sign(blue) + Math.sign(black) + Math.sign(red) + Math.sign(green);
            if(deckColors >= 4){
                let configOptions = document.getElementById("approx-config");
                configOptions.hidden = false;
            }
            // deck is loaded, unlock compute button
            let computeButton = document.getElementById("compute-button");
            computeButton.disabled = false;
            console.log('processed');
        }

        // on startup, disable the compute button until the user loads their deck
        function disableButton(){
            let computeButton = document.getElementById("compute-button");
            computeButton.disabled = true;
        }

        // for any error we want to display, print it to the output box
        function addError(errorText){
            let error = document.createElement("div");
            error.innerText = errorText;
            error.classList.add("error-text");
            document.getElementById("analyzer-result-box").appendChild(error);
        }

        // procedurally add rows to the analysis output table
        // type: "th" for table header, "td" for table data
        function tableRow(c1, c2, c3, type){
            newRow = document.createElement("tr");
            cell1 = document.createElement(type);
            cell1.innerText = c1;
            cell2 = document.createElement(type);
            cell2.innerText = c2;
            cell3 = document.createElement(type);
            cell3.innerText = c3;
            if(type == "td"){
                cell2.classList.add("table-num");
                cell3.classList.add("table-num");
            }
            newRow.appendChild(cell1);
            newRow.appendChild(cell2);
            newRow.appendChild(cell3);
            return newRow;
        }

        // batching all those little functions up into one big "run the analysis" function
        function deepAnal(){
            let textOut = "";
            manaDict = new Map();
            calcMullLands();

            /*console.log("lands: " + landCount);
            console.log(landTypes.slice());
            console.log(mullLands);
            console.log(landsAtTurn(1));*/
            let count = 1;
            
            //calculate for one drops based on mana from lands
            oneDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!oneDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        oneDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan one drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 1){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        landTypes[landIndex] += count * typeMult;
                        landCount += count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            //console.log(landsAtTurn(1));

            //calculate for two drops based on mana from lands and one drops
            twoDropDict = new Map();
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let pips = colorReqs(deckList[i].colorCost);
                    let pipCode = pipsToNum(pips);
                    if(!twoDropDict.has(pipCode)){
                        iterations = 0;
                        castDistro = pipDist(pips);
                        twoDropDict.set(pipCode, castDistro.slice());
                        //console.log(deckList[i].mana_cost + ": " + iterations);
                    }
                }
            }

            //scan two drops for mana sources
            for(let i = 0; i < deckList.length; i++){
                if(deckList[i].colorCost.t == 2){
                    let landIndex = findLandIndex(deckList[i].mana_source);
                    let typeMult = 1;
                    if(deckList[i].card_type.includes("Artifact")){
                        typeMult = 0.75;
                    }
                    if(deckList[i].card_type.includes("Creature")){
                        typeMult = 0.5;
                    }
                    if(deckList[i].mana_source.fetch){
                        if(deckColors >= 3){
                            typeMult = 0.67;
                        }
                        else{
                            typeMult = 1;
                        }
                    }
                    if(landIndex != 0){
                        landTypes[landIndex] += count * typeMult;
                        landCount += count * typeMult;
                        //console.log("SOURCE: " + cardList[i]);
                    }
                    else{
                        //console.log("NO SOURCE: " + cardList[i]);
                    }
                }
            }

            //console.log("lands: " + landCount);
            //console.log(landTypes.slice());
            calcMullLands(landCount);
            //console.log(mullLands);
            
            // calculate for 3 and above based on lands, 1, and 2
            // maybe I should account for 3 on its own first. 3 mana ramp is definitely a thing
            for(let i = 0; i < deckList.length; i++){
                
                let pips = colorReqs(deckList[i].colorCost);
                let pipCode = pipsToNum(pips);
                if(!manaDict.has(pipCode)){
                    iterations = 0;
                    castDistro = pipDist(pips);
                    manaDict.set(pipCode, castDistro.slice());
                    //console.log(deckList[i].mana_cost + ": " + iterations);
                }
            }
            // now that all of the mana values are calculated for and added to the dictionary, add up all the relevant info and return it
            let costsCovered = new Set();
            let cmcOnCurve = 0;
            let totalCmcDelay = 0;
            let totalCmc = 0;
            for(let i = 0; i < deckList.length; i++){
                if(!deckList[i].card_type.includes("Land")){
                    let turnCastDist = turnsToCast(deckList[i].colorCost)
                    let cmc = Math.min(deckList[i].colorCost.t, 10);
                    let onCurveRate = turnCastDist[cmc];
                    let avgDelay = mean(turnCastDist) - deckList[i].colorCost.t;
                    cmcOnCurve += onCurveRate * cmc;
                    totalCmcDelay += avgDelay * cmc;
                    totalCmc += cmc;
                    if(!costsCovered.has(deckList[i].mana_cost)){
                        costsCovered.add(deckList[i].mana_cost);
                    }
                }
            }
            cmcOnCurve /= totalCmc;
            totalCmcDelay /= totalCmc;
            console.log("curve rate: " + cmcOnCurve);
            console.log("average delay: " + totalCmcDelay);
            return [cmcOnCurve, totalCmcDelay, textOut];
        }

        function testVariant(name, landDiff, baseRate, baseDelay){
            let landCountBackup = landCount;
            let landTypesBackup = landTypes.slice();
            for(let i = 0; i < 32; i++){
                landCount += landDiff[i];
                landTypes[i] += landDiff[i];
            }
            let analResult = deepAnal();
            let newRate = analResult[0] - baseRate;
            let newDelay = analResult[1] - baseDelay;
            let rateText;
            let delayText;
            if(newRate < 0){
                rateText = (newRate * 100).toFixed(2) + "%";
            }
            else{
                rateText = "+" + (newRate * 100).toFixed(2) + "%";
            }
            if(newDelay < 0){
                delayText = newDelay.toFixed(3);
            }
            else{
                delayText = "+" + newDelay.toFixed(3);
            }
            landCount = landCountBackup;
            landTypes = landTypesBackup.slice();
            return tableRow(name, rateText, delayText, "td");
        }

        function createDiff(indices){
            let diff = new Array(32).fill(0);
            for(let i = 0; i < indices.length; i++){
                diff[indices[i][0]] += indices[i][1];
            }
            return diff;
        }

        // this is the one tied to the compute button
        function colorTest(){
            // grab input from calculator
            var textType = Node.textContent ? 'textContent' : 'innerText',
                L = document.getElementById('decklist').value,
                result = document.getElementById('analyzer-result');
            
            approxColors = parseFloat(document.getElementById('approx-colors').value) || 10000;
            approxSamples = parseFloat(document.getElementById('approx-samples').value) || 5;
            let landCountBackup = landCount;
            let landTypesBackup = landTypes.slice();
            let startTime = Date.now();

            //create a fresh table for the analysis output
            let table = document.getElementById("output-table");
            if(table != null){
                table.remove();
            }
            table = document.createElement("table");
            table.id = "output-table";
            table.appendChild(tableRow("Manabase Variation", "Cast Rate", "Average Delay", "th"));

            // run analysis on base deck
            let analResult = deepAnal();
            let baseRate = analResult[0];
            let baseDelay = analResult[1];
            table.appendChild(tableRow("Current Manabase", (baseRate * 100).toFixed(1) + "%", baseDelay.toFixed(3), "td"));

            let endTime = Date.now();
            if(endTime - startTime > 1500){
                console.log(`Execution time: ${endTime - startTime} ms`);
                //result[textType] = result[textType] + "\nLand impact analysis cancelled, predicted runtime too high";
                document.getElementById("analyzer-result-box").appendChild(table);
                addError("Error: Land impact analysis cancelled, predicted runtime too high");
                return;
            }
            landCount = landCountBackup;
            landTypes = landTypesBackup;
            
            // calculate for +1 wastes variant
            table.appendChild(testVariant("+1 Wastes", createDiff([[0, 1]]), baseRate, baseDelay));
            // calculate for variants with all the colors present in the deck
            if(white > 0){
                table.appendChild(testVariant("+1 Plains", createDiff([[1, 1]]), baseRate, baseDelay));
            }
            if(blue > 0){
                table.appendChild(testVariant("+1 Island", createDiff([[2, 1]]), baseRate, baseDelay));
            }
            if(black > 0){
                table.appendChild(testVariant("+1 Swamp", createDiff([[4, 1]]), baseRate, baseDelay));
            }
            if(red > 0){
                table.appendChild(testVariant("+1 Mountain", createDiff([[8, 1]]), baseRate, baseDelay));
            }
            if(green > 0){
                table.appendChild(testVariant("+1 Forest", createDiff([[16, 1]]), baseRate, baseDelay));
            }
            document.getElementById("analyzer-result-box").appendChild(table);

            endTime = Date.now();
            console.log(`Execution time: ${endTime - startTime} ms`);

            console.log(landTypes);
        }
    </script>
    <div class="analyzer" name="deckEntry">
        <p class="title"> Manabase Analyzer</p>
        <p class="prompt"> Paste your decklist here </p>
        <textarea id="decklist" rows="10" cols="50">Paste your exported decklist here (format: '1 sol ring')</textarea>
        <div id="approx-config" hidden>
            <p>It looks like your deck has 4 or more colors. The time it takes to fully evaluate the support for a card increases exponentially with the number of colors in its mana cost. It might take a few seconds to complete the analysis. These settings can also help with this by using imperfect estimates for the most time-consuming cards:</p>
            <p class="prompt"> Estimate cards with <input type="text" id="approx-colors" value="5" style="width: 30px"> or more colors </p>
            
            <p class="prompt"> Estimation samples </p>
            <input type="text" id="approx-samples" value="10000">
        </div>
        <p>
            <input type="button" value="Load" onclick="loadDict()">
            <input type="button" id="compute-button" value="Compute" onclick="colorTest()">
        </p>
        <div class="result-box" id="analyzer-result-box">
            <p id='analyzer-result' class="result-text"></p>
        </div>
    </div>
    <!-- These info boxes can probably just be on the website itself. This is an embed after all
    <div style="float:left">
        <div class = "info-box" name="info">
            <p class="title"> How to Use</p>
            <ol type="1">
                <li>Paste your decklist into the entry box in the format [1 cardname]. You can get this using the "export to Arena" option on most deckbuilders and removing any extra lines that aren't in this format</li>
                <li>Click "Load" to retrieve the cards in your deck from our database</li>
                <li>Click "Compute" to analyze your deck</li>
            </ol>
            <p>This analyzer is built to test how well your deck's manabase can support its spells, and identify where it needs improvement. It does so by calculating 2 metrics:</p>
            <ol type="1">
                <li>Cast rate: For a spell with a mana value of X, what is the probability that you will have the mana available to cast it on turn X?</li>
                <li>Average Delay: On average, how many turns do you have to wait past turn X to be able to cast a spell? (this includes cases where it can be cast immediately)</li>
            </ol>
            <p>These two tend to be fairly closely related, with every 1% drop in cast rate leading to a roughly 0.03 turn increase in cast delay. However, cast delay can account for colors that have fewer sources in your deck and take longer to topdeck</p>
            <p>In general, a 90% cast rate or 0.3 average delay indicates that your deck has strong support from its manabase, while an 80% cast rate or 0.6 average delay is in need of improvement</p>
            <p>This analyzer recommends improvements by calculating these values for multiple variations on your manabase: one with an extra wastes, and one for each basic land type with an extra copy of that land</p>
            <p>The "+1 Wastes" variation is a good metric for how well your deck can support the mana values of your cards. If it's coming back with more than +1% cast rate and -0.03 average delay, your deck probably needs more lands in general</p>
            <p>The "+1 Basic" variations act as metric for how well your deck can support the color requirements of your cards. If the "+1 Plains" variation is only slightly better than the "+1 Wastes" variation, then your deck has the support for white it needs. But if it is a much larger imrpvement than "+1 Wastes", then your deck might need more white sources in general</p>
        </div>
        <div class = "warning-box" name="warning">
            <p class="angry-title"> Warning: This is an incomplete prototype</p>
            <p>While the basic functionality is in place, this tool does not have the capacity to accurately evaluate every type and source of mana present in Magic: the Gathering. 
                Here are some features that the current iteration does not know how to handle:</p>
            <ul>
                <li>Split Pips</li>
                <li>Colorless Mana</li>
                <li>Snow Mana</li>
                <li>Fetchable Duals/Triomes</li>
                <li>Using draw/scry/surveil to get more lands</li>
                <li>MDFC's (basic functionality is in place, but nuance is missing)</li>
                <li>Fetching in forms other than "Search your library for ___"</li>
                <li>Playing spells early due to ramp (any ramp is treated like extra lands)</li>
                <li>Ramp spells that can gain multiple sources (i.e. Cultivate)</li>
                <li>Choosing a ramp piece as a commander (i.e. <a href="https://www.youtube.com/watch?v=ceILMLrNCGw">Snail's Radha Deck</a>)</li>
                <li>Cards with very high mana value (10 is the absolute maximum, but 8 and above might get some strange results)</li>
            </ul>
            <p style="margin-bottom: 0px">In general, this analyzer is built to evaluate a traditional curve out (turn 1: 1-drop, turn 2: 2-drop, etc), and the less your deck's rollout looks like this, the less applicable this analysis will be</p>
        </div>
    </div> -->
</body>
